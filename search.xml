<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Qt创建新文件报错</title>
      <link href="/Qt%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99.html"/>
      <url>/Qt%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99.html</url>
      
        <content type="html"><![CDATA[<p>使用Qt Creator创建新文件后，可能出现一系列不影响编译的报错，包括一些Qt特有的类库。</p><p>解决办法：点击构建套件中的release，清除报错信息，再重新构建即可。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】print()函数的使用</title>
      <link href="/python%E4%B8%AD%E7%9A%84%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0.html"/>
      <url>/python%E4%B8%AD%E7%9A%84%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="print-函数的使用"><a href="#print-函数的使用" class="headerlink" title="print()函数的使用"></a>print()函数的使用</h1><h2 id="print-函数可以输出哪些内容？"><a href="#print-函数可以输出哪些内容？" class="headerlink" title="print()函数可以输出哪些内容？"></a>print()函数可以输出哪些内容？</h2><ul><li>数字</li><li>字符串</li><li>含有运算符的表达式</li></ul><h2 id="print-函数可以输出到哪里？"><a href="#print-函数可以输出到哪里？" class="headerlink" title="print()函数可以输出到哪里？"></a>print()函数可以输出到哪里？</h2><ul><li>显示器</li><li>文件</li></ul><h2 id="print-函数的输出形式"><a href="#print-函数的输出形式" class="headerlink" title="print()函数的输出形式?"></a>print()函数的输出形式?</h2><ul><li>换行</li><li>不换行</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">520</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出到文件中</span></span><br><span class="line">fp=<span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;a+&#x27;</span>) <span class="comment"># a+的含义是以读写的方式打开这个文件</span></span><br><span class="line"><span class="comment"># 同时，参数为a+时，如果文件不存在就创建，如果文件存在就在后面追加</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;helloworld&#x27;</span>,file=fp)</span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#不进行换行输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27; love &#x27;</span>,<span class="string">&#x27;cyo&#x27;</span>,<span class="string">&#x27;!&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的::运算符</title>
      <link href="/C++%E4%B8%AD%E7%9A%84-%E8%BF%90%E7%AE%97%E7%AC%A6.html"/>
      <url>/C++%E4%B8%AD%E7%9A%84-%E8%BF%90%E7%AE%97%E7%AC%A6.html</url>
      
        <content type="html"><![CDATA[<p>$::$ 是运算符中优先级最高的，其用法有三种：</p><p>一、全局作用域符</p><p>当全局变量和局部变量重名的时候，在变量名前加上 $::$ 就可以调用全局变量</p><p>全局函数也是如此</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">用法 (::name)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=x;</span><br><span class="line">    ::sum+=sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、类作用域符</p><p>用来标明类的变量、函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">用法 (<span class="keyword">class</span>::name)</span><br><span class="line"></span><br><span class="line">Clock::<span class="built_in">SetTime</span>(<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s);</span><br></pre></td></tr></table></figure><p>三、命名空间作用域符</p><p>用来注明所使用的类、函数属于哪一个命名空间的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">用法 (<span class="keyword">namespace</span>::name)</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类与对象</title>
      <link href="/C++%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1.html"/>
      <url>/C++%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1.html</url>
      
        <content type="html"><![CDATA[<p>$C++$ 面向对象的三大特性：封装、继承、多态</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ul><li>将抽象出的数据成员、代码成员相结合，将它们视为一个整体</li><li>目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员</li></ul><h2 id="声明形式"><a href="#声明形式" class="headerlink" title="声明形式"></a>声明形式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名称&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    公有成员（外部接口）</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    私有成员</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    保护型成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$public$ ：公共权限，类内可访问、类外可访问</li><li>$protected$ ：保护权限，类内可访问、类外不可访问，儿子可以访问父亲的保护内容</li><li>$private$ ：私有权限，类内可访问、类外不可访问，儿子不可以访问父亲的私有内容<ul><li>如果紧跟在类名称的后面声明私有成员、则关键字 $private$ 可以省略</li></ul></li></ul><h2 id="访问形式"><a href="#访问形式" class="headerlink" title="访问形式"></a>访问形式</h2><ul><li><p>类中成员互访</p><ul><li><p>直接使用成员名</p></li><li><p>this-&gt;成员名</p></li><li><p>(*this).成员名</p></li></ul></li><li><p>类外访问—-仅能访问public属性的成员</p><ul><li>对象名.成员名</li><li>对象指针-&gt;成员名</li></ul></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态</p><ul><li><p>没有返回值，也不写 $void$ </p></li><li><p>在对象创建时由系统自动调用，且只会调用一次</p></li><li><p>如果程序中未声明则系统自动产生出一个默认形式的构造函数</p></li><li><p>允许为内联函数、重载函数、带默认形参值的函数</p></li></ul><p>拷贝构造函数是一种特殊的构造函数，其形参为本类的对象引用。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">类名(形参);<span class="comment">//构造函数</span></span><br><span class="line">类名(类名&amp;对象名);<span class="comment">//拷贝构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">类名::类(类名&amp;对象名)<span class="comment">//拷贝构造函数的实现</span></span><br><span class="line">&#123;函数体&#125;</span><br></pre></td></tr></table></figure><ul><li>调用函数时，若函数的形参为类对象，实参赋值给形参时，系统自动调用拷贝构造函数</li><li>当函数的返回值是类对象时，系统自动调用拷贝构造函数</li></ul><p>如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个默认的拷贝构造函数，其功能是用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。</p><p>调用拷贝构造函数的情况：</p><p>① 程序中需要新建立一个对象，并用另一个同类的对象对它初始化。</p><p>② 当函数的参数为类的对象时。在调用函数时需要将实参对象完整地传递给形参，也就是需要建立一个实参的拷贝，这就是按实参复制一个形参，系统是通过调用复制构造函数来实现的，这样能保证形参具有和实参完全相同的值。</p><p>③ 函数的返回值是类的对象。在函数调用完毕将返回值带回函数调用处时。此时需要将函数中的对象复制一个临时对象并传给该函数的调用处</p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>完成对象被删除前的一些清理工作，在对象的生存期结束的时刻系统自动调用它，然后再释<br>放此对象所属的空间</p><ul><li>如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~类名()&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Clock</span>(<span class="type">int</span> h=<span class="number">8</span>,<span class="type">int</span> m=<span class="number">0</span>,<span class="type">int</span> s=<span class="number">0</span>);    <span class="comment">//构造函数 </span></span><br><span class="line"><span class="built_in">Clock</span>(Clock &amp;clock);               <span class="comment">//拷贝构造函数 </span></span><br><span class="line">~<span class="built_in">Clock</span>();                          <span class="comment">//析构函数 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetTime</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> Hour;</span><br><span class="line"><span class="type">int</span> Minute;</span><br><span class="line"><span class="type">int</span> Second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::<span class="built_in">Clock</span>(<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s) &#123;Hour=h,Minute=m,Second=s;&#125;</span><br><span class="line"><span class="comment">//this-&gt;Hour=h;</span></span><br><span class="line"><span class="comment">//(*this).Hour=h;</span></span><br><span class="line"></span><br><span class="line">Clock::<span class="built_in">Clock</span>(Clock &amp;c)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;Hour=c.Hour;</span><br><span class="line"><span class="keyword">this</span>-&gt;Minute=c.Minute;</span><br><span class="line"><span class="keyword">this</span>-&gt;Second=c.Second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Clock::~<span class="built_in">Clock</span>() &#123;Hour=Minute=Second=<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Clock::SetTime</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(h&gt;=<span class="number">24</span>||h&lt;<span class="number">0</span>) h=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m&lt;<span class="number">0</span>||m&gt;<span class="number">60</span>) m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(s&lt;<span class="number">0</span>||s&gt;<span class="number">60</span>) s=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//if(h&gt;24||h&lt;0||m&lt;0||m&gt;60||s&lt;0||s&gt;60) return ;</span></span><br><span class="line"><span class="keyword">this</span>-&gt;Hour=h;</span><br><span class="line"><span class="keyword">this</span>-&gt;Minute=m;</span><br><span class="line"><span class="keyword">this</span>-&gt;Second=s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Clock::ShowTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">2</span>)&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>)&lt;&lt;<span class="keyword">this</span>-&gt;Hour&lt;&lt;<span class="string">&#x27;:&#x27;</span></span><br><span class="line">         &lt;&lt;<span class="built_in">setw</span>(<span class="number">2</span>)&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>)&lt;&lt;<span class="keyword">this</span>-&gt;Minute&lt;&lt;<span class="string">&#x27;:&#x27;</span></span><br><span class="line"> &lt;&lt;<span class="built_in">setw</span>(<span class="number">2</span>)&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>)&lt;&lt;<span class="keyword">this</span>-&gt;Second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Hello World&quot;</span>&lt;&lt;endl;</span><br><span class="line">Clock c1;</span><br><span class="line">c1.<span class="built_in">ShowTime</span>();                     <span class="comment">//无参构造函数 </span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n---------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="function">Clock <span class="title">c2</span><span class="params">(<span class="number">19</span>,<span class="number">34</span>,<span class="number">52</span>)</span></span>;                <span class="comment">//含参构造函数 </span></span><br><span class="line">c2.<span class="built_in">ShowTime</span>();      </span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n---------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="function">Clock <span class="title">c3</span><span class="params">(c2)</span></span>;                      <span class="comment">//拷贝构造函数 </span></span><br><span class="line">c3.<span class="built_in">ShowTime</span>();      </span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n---------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">c3.<span class="built_in">SetTime</span>(<span class="number">16</span>,<span class="number">35</span>,<span class="number">24</span>);</span><br><span class="line">c3.<span class="built_in">ShowTime</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元是 $C++$ 提供的一种破坏数据封装和数据隐藏的机制<br>通过将一个模块声明为另一个模块的友元，来引用另一个模块中本来被隐藏的信息。<br>可以使用友元函数和友元类。<br>为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元</p><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数是在类声明中由关键字 $friend$ 修饰说明的成员函数，在它的函数体中能够通过对象名访问 $private$ 和 $protected$ 成员<br>作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择。</p><p>访问对象中的成员必须通过对象名。</p><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员。<br>声明语法：将友元类名在另一个类中使用 $friend$ 修饰说明</p><h1 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h1><p>保持已有类的特性而构造新类的过程称为<strong>继承</strong>，在已有类的基础上新增自已的特性而产生新类的过程称为<strong>派生</strong>。<br>被继承的已有类称为基类（或父类），派生出的新类称为派生类。</p><ul><li>继承的目的：实现见代码重用</li><li>派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造</li></ul><p>声明形式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: 继承方式 基类名&#123;</span><br><span class="line">    成员声明;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h2><table><thead><tr><th>基类</th><th>公有继承</th><th>保护继承</th><th>私有继承</th></tr></thead><tbody><tr><td>public</td><td>派生类的public成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>protected</td><td>派生类的protected成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>private</td><td>在派生类中不可见</td><td>在派生类中不可见</td><td>在派生类中不可见</td></tr></tbody></table><h3 id="类型兼容规则"><a href="#类型兼容规则" class="headerlink" title="类型兼容规则"></a>类型兼容规则</h3><p>一个公有派生类的对象在使用上可以被当作基类的对象</p><p>如果  C 公有继承了 B ，则称 “C is a B”</p><ul><li>派生类的对象可以被赋值给基类对象。</li><li>派生类的对象可以初始化基类的引用。</li><li>指向基类的指针也可以指向派生类。</li></ul><p><strong>通过基类对象名、指针只能使用从基类继承的成员</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B0</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;B0::display()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>:<span class="keyword">public</span> B0 &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;B1::display()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>:<span class="keyword">public</span> B1 &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;D1::display()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(B0 *ptr)</span> </span>&#123;ptr-&gt;<span class="built_in">display</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">B0 b0,*p;</span><br><span class="line">B1 b1;</span><br><span class="line">D1 d1;</span><br><span class="line"></span><br><span class="line">p=&amp;b0,<span class="built_in">fun</span>(p);</span><br><span class="line">p=&amp;b1,<span class="built_in">fun</span>(p);</span><br><span class="line">p=&amp;d1,<span class="built_in">fun</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B0::display()</span><br><span class="line">B0::display()</span><br><span class="line">B0::display()</span><br></pre></td></tr></table></figure><p>三次调用函数都只调用了基类的display函数。</p><h2 id="单继承与多继承"><a href="#单继承与多继承" class="headerlink" title="单继承与多继承"></a>单继承与多继承</h2><ul><li>单继承：派生类只从一个基类派生</li><li>多继承：派生类从多个基类派生</li><li>多重派生：由一个基类派生出多个不同的派生类。</li><li>多层派生：派生类又作为基类，继续派生新的类。</li></ul><p>多继承派生类的声明方式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: 继承方式<span class="number">1</span> 基类名<span class="number">1</span>,继承方式<span class="number">2</span> 基类名<span class="number">2</span>，.&#123;</span><br><span class="line">    成员声明;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个“继承方式”，只用于限制对紧随其后之基类的继承。</p><h2 id="派生类的构造、析构函数"><a href="#派生类的构造、析构函数" class="headerlink" title="派生类的构造、析构函数"></a>派生类的构造、析构函数</h2><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>当基类中声明有默认形式的构造函数或未声明构造函数时，派生类构造函数可以不向基类构造函数传递参数。</li><li>若基类中未声明构造函数，派生类中也可以不声明，全采用默认形式构造函数。</li><li><strong>当基类声明有带形参的构造函数时，派生类也应声明带形参的构造函数，并将参数传递给基类构造函数。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">派生类名::派生类名(基类<span class="number">1</span>形参,基类<span class="number">2</span>形参,...基类n形参,本类形参):</span><br><span class="line">基类名<span class="number">1</span>(参数),基类名<span class="number">2</span>(参数),....基类名<span class="built_in">n</span>(参数),对象数据成员的初始化&#123;</span><br><span class="line">    本类成员初始化赋值语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数的调用顺序"><a href="#构造函数的调用顺序" class="headerlink" title="构造函数的调用顺序"></a>构造函数的调用顺序</h3><ol><li>调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向石）。</li><li>调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序</li><li>派生类的构造函数体中的内容</li></ol><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul><li>若建立派生类对象时调用默认拷贝构造函数，则编译器将自动调用基类的默认拷贝构造函数</li><li>若编写派生类的拷贝构造函数，则需要为基类相应的拷贝构造函数传递参数。</li></ul><h3 id="析构函数-1"><a href="#析构函数-1" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数也不被继承，派生类自行声明，声明方法与一般（无继承关系时）类的析构函数相同。</p><ul><li>不需要显式地调用基类的析构函数，系统会自动隐式调用</li><li>析构函数的调用次序与构造函数相反</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//基类B1,构造函数有参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B1</span>(<span class="type">int</span> i) &#123;cout&lt;&lt;<span class="string">&quot;constructing B1 &quot;</span>&lt;&lt;i&lt;&lt;endl;&#125;</span><br><span class="line">~<span class="built_in">B1</span>() &#123;cout&lt;&lt;<span class="string">&quot;destructing B1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类B2，构造函数有参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B2</span>(<span class="type">int</span> j) &#123;cout&lt;&lt;<span class="string">&quot;constructing B2 &quot;</span>&lt;&lt;j&lt;&lt;endl;&#125;</span><br><span class="line">~<span class="built_in">B2</span>() &#123;cout&lt;&lt;<span class="string">&quot;destructing B2&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类B3，构造函数无参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B3</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B3</span>() &#123;cout&lt;&lt;<span class="string">&quot;constructing B3 *&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">~<span class="built_in">B3</span>() &#123;cout&lt;&lt;<span class="string">&quot;destructing B3&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> B2, <span class="keyword">public</span> B1, <span class="keyword">public</span> B3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//派生类的公有成员</span></span><br><span class="line"><span class="built_in">C</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d):<span class="built_in">B1</span>(a),<span class="built_in">memberB2</span>(d),<span class="built_in">memberB1</span>(c),<span class="built_in">B2</span>(b) &#123;&#125;</span><br><span class="line"><span class="comment">//派生类的私有对象成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">B1 memberB1;</span><br><span class="line">B2 memberB2;</span><br><span class="line">B3 memberB3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">C <span class="title">obj</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">constructing B2 <span class="number">2</span></span><br><span class="line">constructing B1 <span class="number">1</span></span><br><span class="line">constructing B3 *</span><br><span class="line">constructing B1 <span class="number">3</span></span><br><span class="line">constructing B2 <span class="number">4</span></span><br><span class="line">constructing B3 *</span><br><span class="line">destructing B3</span><br><span class="line">destructing B2</span><br><span class="line">destructing B1</span><br><span class="line">destructing B3</span><br><span class="line">destructing B1</span><br><span class="line">destructing B2</span><br></pre></td></tr></table></figure><h2 id="派生类成员的标识与访问"><a href="#派生类成员的标识与访问" class="headerlink" title="派生类成员的标识与访问"></a>派生类成员的标识与访问</h2><h3 id="同名隐藏规则"><a href="#同名隐藏规则" class="headerlink" title="同名隐藏规则"></a>同名隐藏规则</h3><p>当派生类与基类中有同名成员时：</p><ul><li>若未显式指定类名，则通过派生类对象使用的是<strong>派生类中的同名成员</strong>。</li><li>如果派生类中声明了与基类成员函数同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏。</li><li>如要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名限定。</li></ul><h2 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h2><p>声明：用 $virtual$ 修饰说明基类 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> B</span><br></pre></td></tr></table></figure><p>作用</p><ul><li>主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题</li><li>为最远的派生类提供惟一的基类成员，而不重复产生多次拷贝。</li></ul><p>注意：</p><ul><li>在第一级继承时就要将共同基类设计为虚基类。</li></ul><p><img src="/img/Blog/22.12.23_1.png" alt="image_1"></p><h3 id="虚基类及其派生类构造函数"><a href="#虚基类及其派生类构造函数" class="headerlink" title="虚基类及其派生类构造函数"></a>虚基类及其派生类构造函数</h3><ul><li>建立对象时所指定的类称为最（远）派生类。</li><li>虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的</li><li>在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的默认构造函数</li><li>在建立对象时，<strong>只有最派生类的构造函数调用虚基类的构造函数</strong>，该派生类的其他基类对虚基类构造函数的调用被忽略</li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul><li>多态：是指发出同样的消息被不同类型的对象接收时有可能导致完全不同的行为。</li><li>目的：达到行为标识统一，减少程序中标识符的个数</li><li>实现：函数重载、运算符重载、虚函数</li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h3><ul><li>将指定的运算表达式转化为对运算符函数的调用，运算对象转化为运算符<br>函数的实参。</li><li>编系统对重载运算符的选择，遵循函数重载的选择原则，</li></ul><h3 id="规则和限制"><a href="#规则和限制" class="headerlink" title="规则和限制"></a>规则和限制</h3><ul><li><p>可以重载C++中除下列运算符外的所有运算符</p><p>.     .*      ::    ?:</p></li><li><p>只能重载C++语言中已有的运算符，不可臆造新的。</p></li><li><p>不改变原运算符的优先级和结合性</p></li><li><p>不能改变操作数个数。</p></li><li><p>经重载的运算符，其操作数中至少应该有一个是自定义类型</p></li></ul><p>两种形式：类成员函数、非成员函数（通常为友元函数）</p><p>声明形式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span> 运算符(类型 &amp;形参)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载为类成员函数时(后置++、–除外)参数个数&#x3D;原操作数个数-1<br>重载为友元函数时参数个数&#x3D;原操作数个数，且至少应该有一个自定义类型的形参。</p><h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><p>绑定：程序自身彼此关联的过程，确定程序中的操作调用与执行该操作的代码间的关系。<br>静态绑定：绑定过程出现在编译阶段，用对象名或者类名来限定要调用的函数。<br>动态绑定：绑定过程工作在程序运行时执行，在程序运行时才确定将要调用的函数</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数是动态绑定的基础，是非静态的成员函数</p><ul><li>在类的声明中，在函数原型之前写virtual。</li><li>virtual只用来说明类声明中的原型，不能用在函数实现时</li><li>具有继承性，基类中声明了虚函数，派生类中无论是否说明，同原型函数都自动为虚函数</li></ul><p>本质：不是重载声明而是覆盖<br>调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类决定调用哪个函数</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B0</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;B0::display()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>:<span class="keyword">public</span> B0 &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;B1::display()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>:<span class="keyword">public</span> B1 &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;D1::display()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(B0 *ptr)</span> </span>&#123;ptr-&gt;<span class="built_in">display</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">B0 b0,*p;</span><br><span class="line">B1 b1;</span><br><span class="line">D1 d1;</span><br><span class="line"></span><br><span class="line">p=&amp;b0,<span class="built_in">fun</span>(p);</span><br><span class="line">p=&amp;b1,<span class="built_in">fun</span>(p);</span><br><span class="line">p=&amp;d1,<span class="built_in">fun</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>何时需要虚析构函数？</p><ul><li>当你可能通过基类指针删除派生类对象时</li><li>如果你打算充许其他人通过基类指针调用对象的析构函数文（通过delete这样做是正常的），并被析构的对象是有重要的析构函数的派生类的对象，就需要让基类的析构函数成为虚拟的。</li></ul><h2 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h2><p>带有纯虚函数的类称为抽象类</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&#123;</span><br><span class="line">    <span class="keyword">virtual</span> 类型 函数名（参数表）=<span class="number">0</span>；<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>抽象类为抽象和设计的目的而声明，将有关的数据和行为组织在一个继承层次结构中，保证派生类有要求的行为，<br>对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>抽象类只能作为基类来使用。</p></li><li><p>不能声明抽象类的对象。</p></li><li><p>构造函数不能是虚函数，析构函数可以是虚函数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和、差分和离散化</title>
      <link href="/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E5%92%8C%E7%A6%BB%E6%95%A3%E5%8C%96.html"/>
      <url>/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E5%92%8C%E7%A6%BB%E6%95%A3%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P1884-USACO12FEB-Overplanting-S"><a href="#P1884-USACO12FEB-Overplanting-S" class="headerlink" title="P1884 [USACO12FEB]Overplanting S"></a>P1884 [USACO12FEB]Overplanting S</h3><p>相当于地毯（P3397）和火烧赤壁（P1496）的二合一。</p><p>观察到矩形坐标的范围远大于 $n$ 的范围，于是考虑离散化。</p><p>离散化之后变成二维线段覆盖问题，直接暴力枚举相邻的点之间的区域是否被覆盖。</p><p>这样可以过，但是程序用时直逼上限，考虑用二维差分优化。</p><p>首先离散化，处理出</p><p>设 $d[i][j]$为差分数组，则对 $d[i][j]&#x3D;a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$ </p><p>每次覆盖 $(x1,y1)$ 到 $(x2,y2)$ 的矩形时，只需修改 $d[x1][y1]++,d[x1][y2+1]–,d[x2+1][y1]–,d[x2+1][y2+1]++$</p><p>但此时下标表示的是点之间的线段，所以 $x2$ 和 $y2$ 需要减一</p><p>在修改过后对差分数组求前缀和即可得到每一块地是否被覆盖的信息</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2005</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,cntx,cnty;</span><br><span class="line">ll ans;</span><br><span class="line">ll X1[N],X2[N],Y1[N],Y2[N],x[<span class="number">2</span>*N],y[<span class="number">2</span>*N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;X1[i]&gt;&gt;Y1[i]&gt;&gt;X2[i]&gt;&gt;Y2[i];</span><br><span class="line">x[<span class="number">2</span>*i<span class="number">-1</span>]=X1[i],x[<span class="number">2</span>*i]=X2[i];</span><br><span class="line">y[<span class="number">2</span>*i<span class="number">-1</span>]=Y1[i],y[<span class="number">2</span>*i]=Y2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(x+<span class="number">1</span>,x+<span class="number">2</span>*n+<span class="number">1</span>),<span class="built_in">sort</span>(y+<span class="number">1</span>,y+<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">cntx=<span class="built_in">unique</span>(x+<span class="number">1</span>,x+<span class="number">2</span>*n+<span class="number">1</span>)-x<span class="number">-1</span>,cnty=<span class="built_in">unique</span>(y+<span class="number">1</span>,y+<span class="number">2</span>*n+<span class="number">1</span>)-y<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line"><span class="type">int</span> a1=<span class="built_in">lower_bound</span>(x+<span class="number">1</span>,x+cntx+<span class="number">1</span>,X1[k])-x;</span><br><span class="line"><span class="type">int</span> a2=<span class="built_in">lower_bound</span>(x+<span class="number">1</span>,x+cntx+<span class="number">1</span>,X2[k])-x;</span><br><span class="line"><span class="type">int</span> b1=<span class="built_in">lower_bound</span>(y+<span class="number">1</span>,y+cnty+<span class="number">1</span>,Y1[k])-y;</span><br><span class="line"><span class="type">int</span> b2=<span class="built_in">lower_bound</span>(y+<span class="number">1</span>,y+cnty+<span class="number">1</span>,Y2[k])-y;</span><br><span class="line">f[a1][b1]++,f[a1][b2]--,f[a2][b1]--,f[a2][b2]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;cntx;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;cnty;j++)&#123;</span><br><span class="line">f[i][j]+=f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>]-f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">ans+=(f[i][j]!=<span class="number">0</span>)*(x[i+<span class="number">1</span>]-x[i])*(y[j+<span class="number">1</span>]-y[j]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++指针与引用</title>
      <link href="/C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8.html"/>
      <url>/C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存地址与访问方式"><a href="#内存地址与访问方式" class="headerlink" title="内存地址与访问方式"></a>内存地址与访问方式</h1><p>内存地址：系统根据程序中定义变量的类型，给变量分配一定的长度空间。内存区的每个字节都有编号，称之为地址。</p><p>在 $C++$ 中，内存分成5个区：堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区。</p><ol><li><p>栈：由编译器自动分配释放，里面的变量通常是局部变量、函数参数等。</p></li><li><p>堆：由 $malloc$ 等分配的内存块，用 $free$ 来释放。</p></li><li><p>自由存储区：主要是由 $new$ 分配的内存块，释放由应用程序去控制，一般一个 $new$ 就要对应一个 $delete$ 。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p></li><li><p>全局&#x2F;静态存储区：全局变量和静态变量被分配到同一块内存中，在程序启动时分配了它们的存储，但在程序开始执行之前可能不会初始化。</p></li><li><p>常量存储区：里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）。此区域中不能存在类类型的对象。</p></li></ol><blockquote><p>Free Store<br>The free store is one of the two dynamic memory areas, allocated&#x2F;freed by new&#x2F;delete. Object lifetime can be less than the time the storage is allocated; that is, free store objects can have memory allocated without being immediately initialized, and can be destroyed without the memory being immediately deallocated. During the period when the storage is allocated but outside the object’s lifetime, the storage may be accessed and manipulated through a void* but none of the proto-object’s nonstatic members or member functions may be accessed, have their addresses taken, or be otherwise manipulated.</p><p>Heap<br>The heap is the other dynamic memory area, allocated&#x2F;freed by malloc&#x2F;free and their variants. Note that while the default global new and delete might be implemented in terms of malloc and free by a particular compiler, the heap is not the same as free store and memory allocated in one area cannot be safely deallocated in the other. Memory allocated from the heap can be used for objects of class type by placement-new construction and explicit destruction. If so used, the notes about free store object lifetime apply similarly here.</p></blockquote><p>来源：<a href="http://www.gotw.ca/gotw/009.htm">http://www.gotw.ca/gotw/009.htm</a></p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针变量：用于专门存放地址的变量。</p><h2 id="定义方式："><a href="#定义方式：" class="headerlink" title="定义方式："></a>定义方式：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类型表示符 *指针变量名;</span><br></pre></td></tr></table></figure><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>&amp;用来取变量的地址</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p=&amp;i;</span><br><span class="line"><span class="type">int</span> *p=&amp;i;</span><br></pre></td></tr></table></figure><p>*用来取指针指向地址的内容（解地址）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p,a[<span class="number">10</span>];</span><br><span class="line">p=a;</span><br><span class="line">p=&amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>注：</p><ol><li><p>void* 类型的指针可以指向任意类型的变量</p></li><li><p>指针在初始化时一般 int *p&#x3D;NULL;</p></li></ol><h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><p>存放一维或多维数组首地址的指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>,a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>]=a;</span><br><span class="line"><span class="comment">//p是一个指针，它指向包含4个元素的一维数组</span></span><br><span class="line">cout&lt;&lt;*p[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">p++;<span class="comment">//指向下一行的首地址</span></span><br><span class="line">cout&lt;&lt;*p[<span class="number">0</span>]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a代表二维数组的首地址，第<span class="number">0</span>行的地址</span><br><span class="line">a+i代表第i行的地址</span><br><span class="line">*(a+i)即a[i] 代表第i行第<span class="number">0</span>列的地址</span><br><span class="line">*(a+i)+j即a[i]+j 代表第i行第例的地址</span><br><span class="line">*(*(a+i)+j)即a[i][j] 代表第i行第j列的元素</span><br></pre></td></tr></table></figure><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>指向函数的指针变量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">返回值类型 (* 指针变量名)(形参列表);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">bool</span> (*cmp)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">    cmp=max;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">cmp</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可作为某个函数的参数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(Stu a[],<span class="type">int</span> n,<span class="built_in">bool</span> (*cmp)(<span class="type">const</span> Stu &amp;a,<span class="type">const</span> Stu &amp;b))</span><br></pre></td></tr></table></figure><h2 id="作为函数值的返回类型"><a href="#作为函数值的返回类型" class="headerlink" title="作为函数值的返回类型"></a>作为函数值的返回类型</h2><p>可用于<strong>给函数返回值赋值</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> value[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">GetPointerValue</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;<span class="keyword">return</span> &amp;value[i];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">GetPointersValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *r=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) r[i]=value[i];</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;value[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    *<span class="built_in">GetPointerValue</span>(<span class="number">0</span>)=<span class="number">-1</span>;</span><br><span class="line">    cout&lt;&lt;value[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *r=<span class="built_in">GetPointersValue</span>();</span><br><span class="line">    cout&lt;&lt;r[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;r[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;r[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用：给已有的变量取一个别名。</p><p>可理解为“名字”</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> &amp;cnt=n;</span><br></pre></td></tr></table></figure><p>&amp;不是取地址，只是描述别名。编译器不会为 $cnt$ 开辟新的空间。</p><p>引用必须初始化，且初始化后不能更改。</p><h2 id="作为函数参数"><a href="#作为函数参数" class="headerlink" title="作为函数参数"></a>作为函数参数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;a1, <span class="type">int</span> &amp;b1)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp=a1;</span><br><span class="line">    a1=b1;</span><br><span class="line">    b1=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;, b = &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">Swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;, b = &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处：</p><ol><li><p>函数内部直接通过引用来操作外部变量的值；</p></li><li><p>省去了指针的操作；</p></li><li><p>函数的形参不会拥有新的空间（节约了空间）。</p></li></ol><h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a=<span class="number">90</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="作为函数值的返回类型-1"><a href="#作为函数值的返回类型-1" class="headerlink" title="作为函数值的返回类型"></a>作为函数值的返回类型</h2><p>返回类的引用可以作为左值，并且返回的类类型引用可以直接调用成员函数来修改，返回的类类型不会调用复制构造函数。</p><p>可用于<strong>给函数返回值赋值</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">get_val</span><span class="params">(string &amp;str, string::size_type ix)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line">       cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">       <span class="built_in">get_val</span>(s, <span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">       cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态分配内存函数簇"><a href="#动态分配内存函数簇" class="headerlink" title="动态分配内存函数簇"></a>动态分配内存函数簇</h1><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>功能：在堆区开辟指定长度的空间，并且是连续的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br></pre></td></tr></table></figure><p>注：</p><ol><li><p>在调用 $malloc$ 之后，需要判断申请是否成功</p><p>失败返回 $NULL$ ，成功返回开辟好的空间的首地址</p></li><li><p>多次 $malloc$ ，申请的内存不一定是连续的</p></li><li><p>函数返回值类型为void *，需要强制类型转换</p></li></ol><h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><p>功能：在堆区申请指定大小的空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p=(<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">3</span>,<span class="number">100</span>);<span class="comment">//在内存中申请了三块，每块大小为100个字节</span></span><br></pre></td></tr></table></figure><p>注：</p><p>$calloc$ 申请的内存中的内容为0，而 $malloc$ 中的内容随机</p><h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><p>功能：在原本申请好的堆区空间的基础上重新申请内存，新开辟的空间大小为函数的第二个参数</p><p>如果原本申请好的空间的后面不足以增加指定的大小，系统会重新找一个足够大的位置开辟指定的空间，然后将原本空间中的数据拷贝过来，然后释放原本的空间</p><p>如果 $newsize$ 比原先的内存小，则会释放原先内存的后面的存储空间只留前面的 $newsize$ 个字节</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line">p=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">p=(<span class="type">char</span> *)<span class="built_in">realloc</span>(p,<span class="number">150</span>);</span><br><span class="line">p=(<span class="type">char</span> *)<span class="built_in">realloc</span>(p,<span class="number">50</span>);</span><br></pre></td></tr></table></figure><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>功能：释放堆区的空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>$free$ 函数只能释放堆区的空间</li><li>当 $free$ 后，$p$ 变成野指针了，要 $p&#x3D;NULL$</li><li>一块动态申请的内存只能 $free$ 一次，不能多次 $free$</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++运算符优先级</title>
      <link href="/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.html"/>
      <url>/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.html</url>
      
        <content type="html"><![CDATA[<p>第一级： </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[] () . -&gt;</span><br></pre></td></tr></table></figure><p>第二级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (类型) ++ -- * &amp; ! ~ sizeof</span><br></pre></td></tr></table></figure><p>第三级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ * %</span><br></pre></td></tr></table></figure><p>第四级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ -</span><br></pre></td></tr></table></figure><p>第五级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt; &gt;&gt;</span><br></pre></td></tr></table></figure><p>第六级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &gt;= &lt; &lt;=</span><br></pre></td></tr></table></figure><p>第七级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">== !=</span><br></pre></td></tr></table></figure><p>第八~十四级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;</span><br><span class="line">^</span><br><span class="line">|</span><br><span class="line">&amp;&amp;</span><br><span class="line">||</span><br><span class="line">?:</span><br></pre></td></tr></table></figure><h1 id="逻辑中断："><a href="#逻辑中断：" class="headerlink" title="逻辑中断："></a>逻辑中断：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(表达式1)||(表达式2)</span><br><span class="line">若表达式1为真，则不执行表达式2</span><br><span class="line"></span><br><span class="line">(表达式1)&amp;&amp;(表达式2)</span><br><span class="line">若表达式1为假，则不执行表达式2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相当于电路中的断路处理，<del>可用于压行</del></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈&amp;单调队列</title>
      <link href="/%E5%8D%95%E8%B0%83%E6%A0%88&amp;%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97.html"/>
      <url>/%E5%8D%95%E8%B0%83%E6%A0%88&amp;%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>一种内部元素具有单调性的栈</p><h2 id="洛谷P2866-USACO06NOV-Bad-Hair-Day-S"><a href="#洛谷P2866-USACO06NOV-Bad-Hair-Day-S" class="headerlink" title="洛谷P2866 [USACO06NOV]Bad Hair Day S"></a>洛谷P2866 [USACO06NOV]Bad Hair Day S</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有$N (N \leq 80000)$头奶牛，每一头牛都站在一排，身高为$h_i$。<br>对于第$i$头牛前面的第$j$头牛，如果$h_i&gt;h_{i+1}$并且$h_i&gt;h_{i+2}$ $\cdots$ $h_i&gt;h_j$，那么认为第$i$头牛可以看到第$i+1$到第$j$头牛。</p><p>定义$C_i$为第$i$头牛所能看到的别的牛的数量。请帮助农夫约翰求出$\sum_{i&#x3D;1}^n C_i$.</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>考虑一头牛能被几头牛看到。</p><p>形象地来说，就是<del>如果一个人比你小，还比你强，那你就可以退役了</del></p><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索技巧</title>
      <link href="/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html"/>
      <url>/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html</url>
      
        <content type="html"><![CDATA[<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>深度优先搜索（ $Depth$  $First$  $Search$  ）其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次.</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>每次寻找下一个节点的过程是重复的</li><li>如果当前节点没有未访问过的后继节点，则需要<strong>回溯</strong>到有未访问过的后继节点的一个先驱节点，继续遍历</li></ul><p>形象化描述：不撞南墙不回头</p><p>$DFS$ 一般通过递归来实现，本质上用栈来维护。</p><p>大部分 $DFS$ 算法分为三部分：</p><ol><li>判断当前位置是否合法（是否为边界）</li><li>处理信息</li><li>访问下一个位置</li></ol><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><h3 id="最优化剪枝"><a href="#最优化剪枝" class="headerlink" title="最优化剪枝"></a>最优化剪枝</h3><p>设 $g(x)$ 表示从起点走到节点 $x$ 能获得的价值，估价函数 $f(x)$ 为从节点 $x$ 走到终点能获得的最大价值。</p><p>如果 $g(x)+f(x)&lt;$ 当前的已经找到的解，则说明从节点 $x$ 走下去一定得不到最优解，可剪去此分支。</p><h4 id="洛谷P1074-NOIP2009-提高组-靶形数独"><a href="#洛谷P1074-NOIP2009-提高组-靶形数独" class="headerlink" title="洛谷P1074  [NOIP2009 提高组] 靶形数独"></a>洛谷P1074  [NOIP2009 提高组] 靶形数独</h4><p>靶形数独每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。（如图）</p><p> <img src="https://cdn.luogu.com.cn/upload/pic/28.png"> </p><p>每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。 </p><p>求出对于给定的靶形数独，能够得到的最高分数。</p><p>对于 $100%$ 的数据，数独中非 $0$ 数的个数不少于 $24$。</p><hr><p>如果当前得到的分值+之后可能得到的最大的分值还是小于之前的最优答案，结束</p><h3 id="可行性剪枝"><a href="#可行性剪枝" class="headerlink" title="可行性剪枝"></a>可行性剪枝</h3><p>如果当前位置不合法，则返回</p><h4 id="洛谷P1025-NOIP2001-提高组-数的划分"><a href="#洛谷P1025-NOIP2001-提高组-数的划分" class="headerlink" title="洛谷P1025 [NOIP2001 提高组] 数的划分"></a>洛谷P1025 [NOIP2001 提高组] 数的划分</h4><p>将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。</p><p>例如：$n&#x3D;7$，$k&#x3D;3$，下面三种分法被认为是相同的。</p><p>$1,1,5$;<br>$1,5,1$;<br>$5,1,1$.</p><p>问有多少种不同的分法。</p><p>（$6&lt;n \le 200$，$2  \le k  \le  6$）</p><hr><p>$dfs(x,r,l)$ 表示当前正在分第 $x$ 份，剩余 $r$ 没有划分，上一份大小为 $l$</p><p>当 $r&lt;0$ ，说明当前及之后所有位置全部放上个位置的数时，仍比剩余可分配的数要小，退出</p><h3 id="优化搜索顺序"><a href="#优化搜索顺序" class="headerlink" title="优化搜索顺序"></a>优化搜索顺序</h3><p>让不合法的情况在一开始就被剪掉</p><h4 id="洛谷P1074-NOIP2009-提高组-靶形数独-1"><a href="#洛谷P1074-NOIP2009-提高组-靶形数独-1" class="headerlink" title="洛谷P1074 [NOIP2009 提高组] 靶形数独"></a>洛谷P1074 [NOIP2009 提高组] 靶形数独</h4><p>从剩余未填格最少的一行或一列开始填</p><h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><p>如果当前位置之后的信息全部处理过了，就可以直接利用这些信息</p><h4 id="洛谷P1434-SHOI2002-滑雪"><a href="#洛谷P1434-SHOI2002-滑雪" class="headerlink" title="洛谷P1434 [SHOI2002] 滑雪"></a>洛谷P1434 [SHOI2002] 滑雪</h4><p>Michael 喜欢滑雪。可是为了获得速度，滑的区域必须向下倾斜。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1   2   3   4   5</span><br><span class="line">16  17  18  19  6</span><br><span class="line">15  24  25  20  7</span><br><span class="line">14  23  22  21  8</span><br><span class="line">13  12  11  10  9</span><br></pre></td></tr></table></figure><p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24$－$17$－$16$－$1$（从 $24$ 开始，在 $1$ 结束）。当然    $25$－$24$－$23$－$\ldots$－$3$－$2$－$1$ 更长。事实上，这是最长的一条。</p><p>对于 $100%$ 的数据，$1\leq R,C\leq 100$。</p><hr><p>记录从每个点开始的最长滑坡是多少</p><h3 id="玄学剪枝"><a href="#玄学剪枝" class="headerlink" title="玄学剪枝"></a>玄学剪枝</h3><h4 id="洛谷P1120-小木棍"><a href="#洛谷P1120-小木棍" class="headerlink" title="洛谷P1120 小木棍"></a>洛谷P1120 小木棍</h4><p>乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。</p><p>现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。</p><p>给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。</p><p>$1 \leq n \leq 65$，$1 \leq a_i \leq 50$。</p><hr><ol><li><p>原始长度枚举到 <strong>所有木棍的长度和 $&#x2F;2$</strong>  即可，因为此时所有木棍有可能拼成2根木棍，原始长度再大的话只能是所有木棍拼成1根。</p></li><li><p><strong>优化搜索顺序</strong>:  对输入的所有木棍按长度从大到小排序，从长到短地将木棍拼入。</p></li><li><p><strong>玄学 $next$ 数组</strong>：当dfs返回失败，需要更换当前使用的木棍时，不要再用与当前木棍的长度相同的木棍。预处理出了排序后每根木棍后面的最后一根与这根木棍长度相等的木棍（程序中的next数组），它的下一根木棍就是第一根长度不相等的木棍了。（去重）</p></li><li><p><strong>可行性剪枝</strong>: 只找木棍长度不大于未拼长度rest的所有木棍。(二分)</p></li><li><p>如果 **当前长棍剩余的未拼长度 **等于 <strong>当前木棍的长度或原始长度</strong> ，继续拼下去时却失败了，就直接回溯并改之前拼的木棍。</p></li></ol><p>​       1)  当前长棍剩余的未拼长度等于当前木棍的长度时，这根木棍在最优情况下显然是拼到这（如果用更多短木根拼完剩下的这段，把这根木棍留到后面显然不如把更多总长相等的短木棍扔到后面）。如果在最优情况下继续拼下去失败了，那肯定是之前的木棍用错了，回溯改即可。</p><p>​         2) 当前长棍剩余的未拼长度等于原始长度时，说明这根原来的长棍还一点没拼，现在正在放入一根木棍。很明显，这根木棍还没有跟其它棍子拼接，如果现在拼下去能成功话，它肯定是能用上的，即自组或与其它还没用的木棍拼接。但继续拼下去却失败，说明现在这根木棍不能用上，无法完成拼接，所以回溯改之前的木棍。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,S,L,cnt;</span><br><span class="line"><span class="type">int</span> a[<span class="number">71</span>],next[<span class="number">71</span>];</span><br><span class="line"><span class="type">bool</span> v[<span class="number">71</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> last,<span class="type">int</span> rest)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!rest)&#123;</span><br><span class="line">x++,rest=L;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(!v[i]&amp;&amp;a[i]&lt;=rest)&#123;</span><br><span class="line">v[i]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x,i,rest-a[i]);</span><br><span class="line">v[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rest==a[i]||rest==L) <span class="keyword">return</span>;</span><br><span class="line">i=next[i]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=n) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=cnt) &#123;cout&lt;&lt;L&lt;&lt;endl,<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=last+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(!v[i]&amp;&amp;a[i]&lt;=rest)&#123;</span><br><span class="line">v[i]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x,i,rest-a[i]);</span><br><span class="line">v[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rest==a[i]||rest==L) <span class="keyword">return</span>;</span><br><span class="line">i=next[i];</span><br><span class="line"><span class="keyword">if</span>(i==n) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,k;</span><br><span class="line">cin&gt;&gt;cnt;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">50</span>) <span class="keyword">continue</span>;</span><br><span class="line">a[++n]=k,S+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">next[n]=n;</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(a[i]==a[i+<span class="number">1</span>]) next[i]=next[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> next[i]=i;</span><br><span class="line"><span class="keyword">for</span>(L=a[<span class="number">1</span>];L&lt;=S/<span class="number">2</span>;L++)&#123;</span><br><span class="line">cnt=S/L;</span><br><span class="line"><span class="keyword">if</span>(S%L) <span class="keyword">continue</span>;</span><br><span class="line">v[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,L-a[<span class="number">1</span>]);</span><br><span class="line">v[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;S&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>广度优先搜索（$Broad$  $First$  $Search$ ）是一种分层的查找过程，每次将下一层的所有节点加入待访问队列，不像深度优先搜索有回溯的过程。</p><p>同时与深搜用栈来维护不同，广搜一般是用队列来进行维护的。</p><p>具体操作：它是先将起始状态加入队列，然后每次从队列中取出一个状态，将其后继状态加入队列（后继状态指的是由当前状态一步操作可以到达的状态），直到所有状态均被访问为止。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol><li><p>它并不考虑结果的可能位置，而是彻底地搜索所有状态，所以很少有基于 BFS 的启发式算法，也很少对 BFS 进行剪枝。</p></li><li><p>相对于 DFS，BFS 更加难于保存当前节点的状态，所以 BFS <strong>在爆搜中的应用较少。</strong></p></li><li><p>在某一层还没有搜索完时，是不会进入下一层的，也就是说在队列中所有同一深度的状态，是<strong>连续的一段</strong>。</p></li></ol><p>一般的代码实现方式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BFS</span>()&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(初始状态);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();  取出队首元素</span><br><span class="line">        遍历所有相邻且未加入队列的元素</span><br><span class="line">        &#123;</span><br><span class="line">            处理信息</span><br><span class="line">            q.<span class="built_in">push</span>(); 加入队列</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求最小步数一类的题目一般使用 $BFS$</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分学习笔记</title>
      <link href="/%E4%BA%8C%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/%E4%BA%8C%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>在一段单调的序列上查找一个数，可以采用折半的方法，每次将查找的范围缩小一半</p><h2 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">l=<span class="number">1</span>,r=n;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=a[mid]) r=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;l&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>查找的复杂度为$ \mathcal{O}(\text{log}n)$</p><h2 id="STL函数："><a href="#STL函数：" class="headerlink" title="STL函数："></a>STL函数：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lower_bound</span>(first,last,val);<span class="comment">//first,last及返回值都为迭代器,可在最后加比较器</span></span><br></pre></td></tr></table></figure><p>在非递减区间 $[first,last)$ 中进行二分查找，返回大于或等于 $val$ 的第一个元素位置。如果所有元素都小于 $val$ ，则返回 $last$ 的位置。</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">upper_bound</span>(first,last,val);<span class="comment">//first,last及返回值都为迭代器,可在最后加比较器</span></span><br></pre></td></tr></table></figure><p>在非递减区间 $[first,last)$ 中进行二分查找，返回大于 $val$ 的第一个元素位置。如果所有元素都小于$val$ ，则返回 $last$ 的位置。</p><h1 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h1><h2 id="适用条件："><a href="#适用条件：" class="headerlink" title="适用条件："></a>适用条件：</h2><ol><li>最优解满足单调性</li><li>最优解满足有界性</li></ol><p>即：</p><p>对于 $[a,b]$ 区间内的最优解 $x_0,$ 满足：</p><p>$\forall x_1&lt;x_0  , x_1$ 均为次优解，$\forall x_2&gt;x_0,x_2 $ 均为不可行解。</p><h2 id="模板：-1"><a href="#模板：-1" class="headerlink" title="模板："></a>模板：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123; </span><br><span class="line">mid=(l+r)/<span class="number">2</span>; </span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sol</span>(mid)) r=mid<span class="number">-1</span>; </span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line">cout&lt;&lt;l&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>大部分二分答案的题目的框架是不变的，变化的只有两个部分：</p><ol><li><p>$sol$ 函数：根据每个题目写出具体的判断函数，需要注意取等条件</p></li><li><p><strong>最终答案</strong>：需要具体判断</p><p>当 $l&#x3D;&#x3D;r$ 的时候，判断最终答案是 $l$ 还是 $l-1$</p></li></ol><p>一般来说，二分答案的题目的解很难直接求出，但很容易判断一个解是否可行</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="P3017-USACO11MAR-Brownie-Slicing-G"><a href="#P3017-USACO11MAR-Brownie-Slicing-G" class="headerlink" title="P3017 [USACO11MAR]Brownie Slicing G"></a>P3017 [USACO11MAR]Brownie Slicing G</h2><p>看到题目中的<strong>最大值最小</strong>，考虑用二分验证</p><p>前缀和维护即可</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度模板</title>
      <link href="/%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%A8%A1%E6%9D%BF.html"/>
      <url>/%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%A8%A1%E6%9D%BF.html</url>
      
        <content type="html"><![CDATA[<h1 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h1><p><a href="https://www.luogu.com.cn/problem/P1601">P1601 A+B Problem（高精）</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">qmax</span><span class="params">(T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;<span class="keyword">if</span>(x&lt;y) x=y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l1,l2,l;</span><br><span class="line">string s1,s2;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l)</span></span>&#123;        <span class="comment">//翻转</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l/<span class="number">2</span>;i++) <span class="built_in">swap</span>(a[x][i],a[x][l-i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(l1,l2);i++)&#123;</span><br><span class="line">a[<span class="number">0</span>][i]+=a[<span class="number">1</span>][i]+a[<span class="number">2</span>][i];</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>][i]&gt;=<span class="number">10</span>) a[<span class="number">0</span>][i+<span class="number">1</span>]+=a[<span class="number">0</span>][i]/<span class="number">10</span>,a[<span class="number">0</span>][i]%=<span class="number">10</span>,l=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qmax</span>(l,<span class="built_in">max</span>(l1,l2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++) a[<span class="number">1</span>][++l1]=s1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s2.<span class="built_in">size</span>();i++) a[<span class="number">2</span>][++l2]=s2[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(<span class="number">1</span>,l1),<span class="built_in">reverse</span>(<span class="number">2</span>,l2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=l;i&gt;=<span class="number">1</span>;i--) cout&lt;&lt;a[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h1><p><a href="https://www.luogu.com.cn/problem/P1303">P1303 A*B Problem</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">qmax</span><span class="params">(T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;<span class="keyword">if</span>(x&lt;y) x=y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l1,l2,l;</span><br><span class="line">string s1,s2;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l)</span></span>&#123;        <span class="comment">//·­×ª</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l/<span class="number">2</span>;i++) <span class="built_in">swap</span>(a[x][i],a[x][l-i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Plus</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=l1;i++) </span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=l2;j++) a[<span class="number">0</span>][i+j<span class="number">-1</span>]+=a[<span class="number">1</span>][i]*a[<span class="number">2</span>][j];</span><br><span class="line"></span><br><span class="line">l=l1+l2+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=l;i++) </span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>][i]&gt;=<span class="number">10</span>) a[<span class="number">0</span>][i+<span class="number">1</span>]+=a[<span class="number">0</span>][i]/<span class="number">10</span>,a[<span class="number">0</span>][i]%=<span class="number">10</span>,<span class="built_in">qmax</span>(l,i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=l;i&gt;=<span class="number">1</span>;i--) </span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>][l]==<span class="number">0</span>) l=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++) a[<span class="number">1</span>][++l1]=s1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s2.<span class="built_in">size</span>();i++) a[<span class="number">2</span>][++l2]=s2[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(<span class="number">1</span>,l1),<span class="built_in">reverse</span>(<span class="number">2</span>,l2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Plus</span>();</span><br><span class="line"><span class="keyword">if</span>(l==<span class="number">0</span>) cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span>(i=l;i&gt;=<span class="number">1</span>;i--) cout&lt;&lt;a[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h1><p><a href="https://www.luogu.com.cn/problem/P1480">P1480 A&#x2F;B Problem</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">qmax</span><span class="params">(T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;<span class="keyword">if</span>(x&lt;y) x=y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l1,l;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line">string s1;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l)</span></span>&#123;        <span class="comment">//翻转</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l/<span class="number">2</span>;i++) <span class="built_in">swap</span>(a[i],a[l-i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Div</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l1;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">a[i<span class="number">-1</span>]+=(a[i]-(a[i]/x)*x)*<span class="number">10</span>,a[i]/=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;x;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++) a[++l1]=s1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(l1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Div</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=l1;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(a[i]!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>) cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span>(l1=i;i&gt;=<span class="number">1</span>;i--) cout&lt;&lt;a[i]; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针学习笔记</title>
      <link href="/%E5%8F%8C%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/%E5%8F%8C%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>使用两个指针维护一段序列区间，保证左指针一定小于右指针，并且指针只会向右移动。</p><p>右指针每次向右移动一格；对于右指针的每一个位置，左指针也向右移动，直到所代表的区间满足条件为止。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="洛谷P1638-逛画展"><a href="#洛谷P1638-逛画展" class="headerlink" title="洛谷P1638  逛画展"></a>洛谷P1638  逛画展</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>博览馆正在展出由世上最佳的 $m$ 位画家所画的图画。</p><p>游客在购买门票时必须说明两个数字，$a$ 和 $b$，代表他要看展览中的第 $a$ 幅至第 $b$ 幅画（包含 $a,b$）之间的所有图画，而门票的价钱就是一张图画一元。</p><p>Sept 希望入场后可以看到所有名师的图画。当然，他想最小化购买门票的价格。</p><p>请求出他购买门票时应选择的 $a,b$，数据保证一定有解。</p><p>若存在多组解，<strong>输出 $a$ 最小的那组</strong>。</p><p> $1\leq n\le10^6$，$1 \leq a_i \leq m\le2\times10^3$。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>题目需要求区间的两个端点，则可用左右指针分别代表区间的两个端点。</p><p>每次左指针向右移动，直至区间里的数有 $m$ 种为止。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,ans=inf,sum,ansl,ansr;</span><br><span class="line"><span class="type">int</span> a[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">f[a[x]]++;</span><br><span class="line"><span class="keyword">if</span>(f[a[x]]==<span class="number">1</span>) sum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mns</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">f[a[x]]--;</span><br><span class="line"><span class="keyword">if</span>(f[a[x]]==<span class="number">0</span>) sum--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(r=<span class="number">1</span>;r&lt;=n;r++)&#123;</span><br><span class="line"><span class="built_in">add</span>(r);</span><br><span class="line"><span class="keyword">while</span>(sum==m&amp;&amp;l&lt;=r)&#123;</span><br><span class="line"><span class="built_in">mns</span>(++l);</span><br><span class="line"><span class="keyword">if</span>(ans&gt;r-l) ans=<span class="built_in">min</span>(ans,r-l),ansl=l,ansr=r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ansl&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ansr&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="洛谷P4653-CEOI2017-Sure-Bet"><a href="#洛谷P4653-CEOI2017-Sure-Bet" class="headerlink" title="洛谷P4653 [CEOI2017] Sure Bet"></a>洛谷P4653 [CEOI2017] Sure Bet</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>现在有 $n$ 个 $A$ 类灯泡和 $n$ 个 $B$ 类灯泡，每个灯泡都有各自的权值。</p><p>我们将这些灯泡分为 $n$ 组，每组包含一个来自A类的灯泡和一个来自B类的灯泡。</p><p>你可以从中选取任意个灯泡，每选取一个灯泡需要花费 $1$ 的代价。</p><p>在你选取完之后，系统会随机在A类和B类中选择一个类型，并点亮那一类的所有灯泡。你选取的每个点亮的灯泡会给你带来等于它权值的收益。</p><p>现在请你合理选取灯泡，以最大化可能的最小收益。你只需要求出来这个收益即可。</p><p> $1.0\le A_i,B_i\le 1000.0$，$0\le n\le 10^5$。</p><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>当选取的 $A$ 组物品总价值大于 $B$ 组时，只有从 $B$ 组选取才能达到更优解</p><p>从另一组选取时，需要使两组物品的价值尽可能相等</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">qmax</span><span class="params">(T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;<span class="keyword">if</span>(x&lt;y) x=y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N],b[N],ans1,ans2,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,l=<span class="number">0</span>,r;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp),<span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>,cmp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(r=<span class="number">1</span>;r&lt;=n;r++)&#123;</span><br><span class="line">ans1+=a[r];</span><br><span class="line"><span class="built_in">qmax</span>(ans,<span class="built_in">min</span>(ans1-(l+r),ans2-(l+r)));</span><br><span class="line"><span class="keyword">while</span>(ans2&lt;=ans1&amp;&amp;l&lt;=n) ans2+=b[++l],<span class="built_in">qmax</span>(ans,<span class="built_in">min</span>(ans1-(l+r),ans2-(l+r)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.4lf&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用STL函数</title>
      <link href="/%E5%B8%B8%E7%94%A8STL%E5%87%BD%E6%95%B0.html"/>
      <url>/%E5%B8%B8%E7%94%A8STL%E5%87%BD%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-标准模板库-STL-之Vector容器"><a href="#C-标准模板库-STL-之Vector容器" class="headerlink" title="C++标准模板库(STL)之Vector容器:"></a>C++标准模板库(STL)之Vector容器:</h1><p>是一种顺序容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能<strong>动态</strong>拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而vector正好弥补了这个缺陷，它的特征是相当于可分配拓展的数组，它的随机访问快，在末端插入和删除快，在中间插入和删除慢。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v.<span class="built_in">push_back</span>(t)  <span class="comment">//在数组的最后添加一个值为t的元素</span></span><br><span class="line">v.<span class="built_in">pop_back</span>()  <span class="comment">//去掉数组的最后一个数据 </span></span><br><span class="line">v.<span class="built_in">front</span>() 　　　<span class="comment">//返回第一个元素</span></span><br><span class="line">v.<span class="built_in">back</span>()    <span class="comment">//返回最后一个元素</span></span><br><span class="line">v.<span class="built_in">begin</span>()    <span class="comment">//得到数组头的指针，用迭代器接受</span></span><br><span class="line">v.<span class="built_in">end</span>()     <span class="comment">//得到数组的最后一个单元+1的指针，用迭代器接受</span></span><br><span class="line">v.<span class="built_in">clear</span>()    <span class="comment">// 移除容器中所有数据</span></span><br><span class="line">v.<span class="built_in">empty</span>()    <span class="comment">//判断容器是否为空吗，如果为空，则返回true 。</span></span><br><span class="line">v.<span class="built_in">erase</span>(pos)  <span class="comment">//删除pos位置的数据</span></span><br><span class="line">v.<span class="built_in">erase</span>(beg,end)<span class="comment">// 删除[beg,end)区间的数据</span></span><br><span class="line">v.<span class="built_in">size</span>()     <span class="comment">//回容器中实际数据的个数</span></span><br><span class="line">v.<span class="built_in">insert</span>(pos,data) <span class="comment">//在pos处插入数据</span></span><br><span class="line">v[n]        <span class="comment">//返回 v中位置为 n的元素。</span></span><br><span class="line">v.<span class="built_in">at</span>(n)     <span class="comment">// 返回 v中位置为 n的元素</span></span><br></pre></td></tr></table></figure><h1 id="C-标准模板库-STL-之Set容器"><a href="#C-标准模板库-STL-之Set容器" class="headerlink" title="C++标准模板库(STL)之Set容器:"></a>C++标准模板库(STL)之Set容器:</h1><p>关于set，必须说明的是set关联式容器。set作为一个容器也是用来存储同一数据类型的数据类型，并且能从一个数据集合中取出数据，在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">begin</span>()     <span class="comment">//返回指向第一个元素的迭代器</span></span><br><span class="line">s.<span class="built_in">end</span>()      <span class="comment">//返回指向最后一个元素之后的迭代器，不是最后一个元素</span></span><br><span class="line">s.<span class="built_in">clear</span>()     <span class="comment">//清除所有元素   O(n)</span></span><br><span class="line">s.<span class="built_in">count</span>()     <span class="comment">//返回某个值元素的个数O(logn)</span></span><br><span class="line">s.<span class="built_in">empty</span>()    <span class="comment">//如果集合为空，返回true</span></span><br><span class="line">s.<span class="built_in">erase</span>()     <span class="comment">//删除集合中的元素O(logn)</span></span><br><span class="line">s.<span class="built_in">find</span>()      <span class="comment">//返回一个指向被查找到元素的迭代器，如果没找到则返回end()</span></span><br><span class="line">s.<span class="built_in">insert</span>()     <span class="comment">//在集合中插入元素O(logn)</span></span><br><span class="line">s.<span class="built_in">size</span>()     <span class="comment">//集合中元素的数目O(1)</span></span><br></pre></td></tr></table></figure><h1 id="C-标准模板库-STL-之Map映射"><a href="#C-标准模板库-STL-之Map映射" class="headerlink" title="C++标准模板库(STL)之Map映射:"></a>C++标准模板库(STL)之Map映射:</h1><p>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt; m构建了一个字符串到整数的映射。</span><br><span class="line">m.<span class="built_in">begin</span>()     <span class="comment">//返回指向map头部的迭代器</span></span><br><span class="line">m.<span class="built_in">clear</span>(）     <span class="comment">////删除所有元素     O(n)</span></span><br><span class="line">m.<span class="built_in">count</span>()     <span class="comment">//返回指定元素出现的次数O(logn)</span></span><br><span class="line">m.<span class="built_in">empty</span>()     <span class="comment">//如果map为空则返回true</span></span><br><span class="line">m.<span class="built_in">end</span>()      <span class="comment">//返回指向map末尾的迭代器</span></span><br><span class="line">m.<span class="built_in">erase</span>()     <span class="comment">//删除一个元素</span></span><br><span class="line">m.<span class="built_in">find</span>()      <span class="comment">//查找一个元素</span></span><br><span class="line">m.<span class="built_in">insert</span>()    <span class="comment">// 插入元素        O(logn)</span></span><br><span class="line">m.<span class="built_in">max_size</span>()    <span class="comment">//返回可以容纳的最大元素个数</span></span><br><span class="line">m.<span class="built_in">size</span>()      <span class="comment">//返回map中元素的个数 O(1)</span></span><br><span class="line">m.<span class="built_in">swap</span>()      <span class="comment">//交换两个map</span></span><br></pre></td></tr></table></figure><h1 id="使用auto遍历STL容器："><a href="#使用auto遍历STL容器：" class="headerlink" title="使用auto遍历STL容器："></a>使用auto遍历STL容器：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue&lt;int&gt; q;</span><br><span class="line">for(auto i:q) cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日刷题记录</title>
      <link href="/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.html"/>
      <url>/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="2023年"><a href="#2023年" class="headerlink" title="2023年"></a>2023年</h2><p>$3.14$ 洛谷 <a href="https://www.luogu.com.cn/problem/P3017">P3017 USACO11MAR]Brownie Slicing G</a> （二分+前缀和）</p><p>​         洛谷 <a href="https://www.luogu.com.cn/problem/P3406">P3406 海底高铁</a> </p><p>​         洛谷 <a href="https://www.luogu.com.cn/problem/P2882">P2882 USACO07MAR]Face The Right Way G</a> （差分）</p><p>中间写题忘记录了</p><p>$1.26$ 洛谷 <a href="https://www.luogu.com.cn/problem/P1806">P1806 跑步</a>   (背包变式)</p><p>​         洛谷  <a href="https://www.luogu.com.cn/problem/P5020">P5020 NOIP2018 提高组] 货币系统</a>    (满箱问题变形)</p><h2 id="2022年"><a href="#2022年" class="headerlink" title="2022年"></a>2022年</h2><p>$12.5$ 洛谷  [P1884 <a href="https://www.luogu.com.cn/problem/P1884">USACO12FEB]Overplanting S</a>  (二维差分+离散化)</p><p>$11.20$  洛谷  <a href="https://www.luogu.com.cn/problem/P1725">P1725 琪露诺</a>  （单调队列优化DP）</p><p>$11.15$  洛谷  <a href="https://www.luogu.com.cn/problem/P1714">P1714 切蛋糕</a>  （单调队列+前缀和）</p><p>$11.6$   洛谷  <a href="https://www.luogu.com.cn/problem/P3467">P3467 PLA-Postering</a>   (单调栈)</p><p>$11.5$  洛谷  <a href="https://www.luogu.com.cn/problem/P1578">P1578 奶牛浴场</a>  （最大子矩阵）</p><p>$10.23$  洛谷  P7910 [CSP-J 2021] 插入排序（记录下标） </p><p>$10.19$ 洛谷  P4653 [CEOI2017] Sure Bet （贪心+双指针）</p><p>$10.18$ UVA 11572 Unique Snowflakes（双指针+map）</p><p>$10.17$  洛谷  P2216​ 理想的正方形（二维单调队列）</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建中的一些坑</title>
      <link href="/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91.html"/>
      <url>/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91.html</url>
      
        <content type="html"><![CDATA[<h2 id="css无法加载"><a href="#css无法加载" class="headerlink" title="css无法加载"></a>css无法加载</h2><p>解决方法：修改_config.yml配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://username.github.io/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h2 id="博客语言为英文"><a href="#博客语言为英文" class="headerlink" title="博客语言为英文"></a>博客语言为英文</h2><p>解决方法：修改_config.yml配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure><h2 id="报错-Spawn-failed"><a href="#报错-Spawn-failed" class="headerlink" title="报错 Spawn failed"></a>报错 Spawn failed</h2><p>解决办法：依次输入以下命令</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">rm</span> <span class="string">-rf</span> <span class="string">.deploy_git/</span></span><br><span class="line"></span><br><span class="line"><span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">core.autocrlf</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="string">hexo</span> <span class="string">clean</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">g</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">d</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="修改字体后无法显示css"><a href="#修改字体后无法显示css" class="headerlink" title="修改字体后无法显示css"></a>修改字体后无法显示css</h2><p>解决办法：用hexo clean清空缓存后hexo g -d</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>建站小记</title>
      <link href="/%E5%BB%BA%E7%AB%99%E5%B0%8F%E8%AE%B0.html"/>
      <url>/%E5%BB%BA%E7%AB%99%E5%B0%8F%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<p>2020年搭了一个博客，后来电脑重装系统，于是把相关文件备份了一份。</p><p>博客迁移的时候发现_config.yml被删了，脑子一抽把github上的仓库删了又重新开了一个。</p><p>折腾了三天总算是建好了。</p><p>参考：<a href="https://xxxpt.blog.csdn.net/article/details/102557949">https://xxxpt.blog.csdn.net/article/details/102557949</a></p><p>update on 22.8.3： 换了一台游匣G15，这次迁移成功了 ^ _ ^</p><p>$$ 「路漫漫其修远兮，吾将上下而求索。」 $$</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
