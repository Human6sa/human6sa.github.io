<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8086汇编语言：中断</title>
      <link href="/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%9A%E4%B8%AD%E6%96%AD.html"/>
      <url>/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%9A%E4%B8%AD%E6%96%AD.html</url>
      
        <content type="html"><![CDATA[<h2 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a>中断的概念</h2><h3 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h3><p>软件中断又简称内中断，它通常由三种情况引起。 </p><h4 id="由中断指令INT-n引起"><a href="#由中断指令INT-n引起" class="headerlink" title="由中断指令INT n引起"></a>由中断指令INT n引起</h4><p>CPU执行完一条INT n指令后，会立即产生中断，并且调用系统中相应的中断处理子程序来完成中断功能，n指出中断类型。</p><h4 id="由于CPU的某些错误引起"><a href="#由于CPU的某些错误引起" class="headerlink" title="由于CPU的某些错误引起"></a>由于CPU的某些错误引起</h4><p>（1）除法错中断（中断类型号 0）<br>执行除法指令时，若发现除数为0或超过了寄存器所能表达的范围，则立即产生一个类型为0的中断。<br>（2）溢出中断（中断类型号 4）<br>若溢出标志OF置1，由中断指令INTO来处理发生溢出的中断操作；若OF为0，则INTO指令不产生中断，CPU继续运行原程序。  </p><h4 id="为调试程序-DEBUG-设置的中断"><a href="#为调试程序-DEBUG-设置的中断" class="headerlink" title="为调试程序(DEBUG)设置的中断"></a>为调试程序(DEBUG)设置的中断</h4><p>（1）单步中断（中断类型号 1）<br>在DEBUG下执行T命令（或P命令）时，陷阱标志TF置为1，CPU自动产生类型为1的单步中断。产生单步中断时，CPU自动地将PSW、CS和IP的内容入栈保存，然后清除TF、IF。<br>（2）断点中断(中断类型号 3)<br>断点中断也是供DEBUG调试程序使用的。在调试程序时，当CPU执行到断点时便产生中断，这时显示出各寄存器及相关标志，可以查看寄存器或存储单元的内容。设置断点实际上是把一条断点指令INT 3插入到程序中，CPU每执行到断点处的INT 3指令，便产生一个中断。       </p><ul><li>在内中断中，INT n指令和INTO指令产生的中断，以及除法错中断都不能被禁止，并且比任何外部中断的优先权都高。</li></ul><h3 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h3><p>硬件中断是由输入输出外设产生的中断请求引起的中断，又称为外部中断。80X86系统的硬件中断分为可屏蔽中断和不可屏蔽中断两大类。两者都是通过CPU的引脚引入中断请求信号的。 </p><h4 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h4><p>不可屏蔽中断请求信号接到CPU的NMI引脚上，主要是发生电源故障、奇偶校验错、I&#x2F;O通道校验错等紧急情况时系统自动产生的。NMI不可屏蔽中断的中断类型号为2。 </p><h4 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h4><p>可屏蔽中断是键盘、显示器、打印机、磁盘、串行口&#x2F;并行口等外设发出的。由于可屏蔽中断种类较多，各种处理要求不一样，因此系统专门用8259A中断控制器来管理这些中断。</p><h3 id="中断类型与中断向量"><a href="#中断类型与中断向量" class="headerlink" title="中断类型与中断向量"></a>中断类型与中断向量</h3><h4 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h4><p>80X86系统提供了256个中断类型（可用1字节表示），类型号为0～FFH。<br>中断类型代表了不同的中断源，而系统对中断类型的分配按照一定的规则划分。例如0号～4号为内中断，8号～0FH号为8259A中断控制器控制的8个硬件中断，10H～1AH号为BIOS基本输入输出系统专用，21H号为DOS中断系统功能调用等。<br>在256个中断类型中，系统只占用了一部分，还有一些保留的供以后扩展时使用。  </p><h4 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h4><p>与每个中断类型相对应的中断处理子程序都有一个入口地址，即该中断子程序第1条指令的逻辑地址，该入口地址称为中断向量。<br>中断向量存放在系统的中断向量表中。中断向量由段地址和偏移地址构成，占用4个字节单元 。将中断类型号乘以4，找到对应的存储单元就可取出中断向量。</p><h4 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h4><p>优先级分类如下：<br>内部中断（优先级最高）<br>非屏蔽中断（NMI）<br>可屏蔽中断（INTR）<br>单步中断（优先级最低）</p><h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><h4 id="中断响应条件"><a href="#中断响应条件" class="headerlink" title="中断响应条件"></a>中断响应条件</h4><p>满足以下4条，CPU才可以响应中断：<br>（1）  当前的指令周期结束；<br>（2）  采样到有效的中断请求信号；<br>（3）  如果是可屏蔽中断请求INTR，检查中断允许标志IF是否为1，即中断开放；<br>（4） CPU正在执行的程序不是中断服务程序，或者是中断优先级较低的中断服务程序。 </p><p>有几种特殊情况CPU不能响应中断：<br>（1） 当执行到STI指令时，CPU不会马上响应中断。STI指令是开中断指令，要求在开放中断后再执行后续的一条指令后才能响应中断；<br>（2） IRET指令是中断子程序返回指令，它也要求再执行一条后续指令后才能响应中断。这样做的目的是保护系统能够正常运行；<br>（3）当执行MOV SS,AX指令，即向SS段寄存器传送数据时，即使发生了中断，CPU也不会响应；直到本条执行完后，接着再执行一条指令才响应中断。</p><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><p>CPU响应中断之后，就转入中断处理子程序执行。中断处理子程序的编写与子程序类似，也要保护现场和恢复现场。中断处理的内容和中断类型的设置要求相同。<br>中断也允许嵌套。由于中断类型被设置了优先级，如果新发生的中断级别高于现在正在处理的中断，那么CPU中止现有中断处理程序，转去执行较高级别的中断处理程序。  </p><h4 id="中断返回"><a href="#中断返回" class="headerlink" title="中断返回"></a>中断返回</h4><p>中断子程序的最后一条汇编指令必须是IRET中断返回指令。该指令的作用是将保存在堆栈中断点的偏移地址和段地址弹出，修改IP和CS寄存器；再把保存在堆栈中的PSW各标志位弹到FLAGS寄存器中，然后返回到被中断的程序去继续执行。</p><p>中断过程和子程序调用CALL指令和RET返回指令过程类似，但它们也有不同之处。<br>中断的特点：<br>（1）除了用堆栈保存断点的返回地址CS:IP之外，还保存了标志寄存器PSW的内容；<br>（2）在中断发生时，CPU自动清除了IF位和TF位。使执行中断处理过程中，避免再次发生外部中断的干扰。<br>（3）中断返回 指令IRET执行时，除了将断点地址从堆栈中弹出，还将栈中保存的标志位放入标志寄存器FLAGS。</p><h2 id="中断设置"><a href="#中断设置" class="headerlink" title="中断设置"></a>中断设置</h2><h3 id="设置中断向量"><a href="#设置中断向量" class="headerlink" title="设置中断向量"></a>设置中断向量</h3><p>将在DS:DX中的中断向量写入中断向量表中。<br>格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AH=25H </span><br><span class="line">AL=中断类型号</span><br><span class="line">DS:DX=中断向量</span><br><span class="line">INT 21H </span><br></pre></td></tr></table></figure><h3 id="取中断向量"><a href="#取中断向量" class="headerlink" title="取中断向量"></a>取中断向量</h3><p>从中断向量表中取出中断向量放入ES:BX中。<br>格式：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AH=35H</span><br><span class="line">AL=中断类型号</span><br><span class="line">INT 21H </span><br></pre></td></tr></table></figure><h3 id="中断驻留"><a href="#中断驻留" class="headerlink" title="中断驻留"></a>中断驻留</h3><p>中断驻留是一种特殊的退出程序功能，它在退出前保留程序占用的内存，使这些内存单元不被其它程序覆盖或占用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AH=31H</span><br><span class="line">AL=0</span><br><span class="line">DX=驻留程序长度</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><p>AL&#x3D;0表示返回码</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;9-1.asm  笑脸中断程序INT 60H,采用驻留。</span><br><span class="line">.model small</span><br><span class="line">.stack</span><br><span class="line">.code</span><br><span class="line">    mess1 db 0ah,0dh,&#x27;enter interrupt!&#x27;,0ah,0dh,&#x27;$&#x27;</span><br><span class="line">    mess2 db &#x27;exit interrupt!$&#x27;</span><br><span class="line">    mess3 db 0ah,0dh,&#x27;Continue or Quit(c/q)?$&#x27;</span><br><span class="line">;主程序</span><br><span class="line">main proc far</span><br><span class="line">start:</span><br><span class="line">    mov ax,@code</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    ;设置新的中断向量</span><br><span class="line">    mov dx,offset smile_face;获得中断子程序偏移地址</span><br><span class="line">    mov ax,seg smile_face;获得中断子程序段地址</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov al,60h;将现在的60H号</span><br><span class="line">    mov ah,25h;中断向量放入中断向量表中</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">    ;应用部分</span><br><span class="line">    conti:</span><br><span class="line">        mov dx,offset mess1;显示提示1</span><br><span class="line">        mov ah,9</span><br><span class="line">        int 21h</span><br><span class="line">        int 60h;触发60H号中断，进入中断子程序执行</span><br><span class="line">        mov dx,offset mess2;显示提示2</span><br><span class="line">        mov ah,9</span><br><span class="line">        int 21h</span><br><span class="line">        mov dx,offset mess3;显示提示3</span><br><span class="line">        mov ah,9</span><br><span class="line">        int 21h</span><br><span class="line">        mov ah,1;键入选择</span><br><span class="line">        int 21h</span><br><span class="line">        cmp al,&#x27;c&#x27;</span><br><span class="line">    je conti</span><br><span class="line"></span><br><span class="line">    ;将中断子程序驻留内存</span><br><span class="line">    mov al,0</span><br><span class="line">    mov ah,31h         ;驻留功能</span><br><span class="line">    mov dx,smiend-smigin+16  ; 中断子程序长度</span><br><span class="line">    int 21h</span><br><span class="line">main endp         ;主程序结束</span><br><span class="line"></span><br><span class="line">;中断子程序</span><br><span class="line">smile_face proc far </span><br><span class="line">smigin:</span><br><span class="line">    sti;开中断</span><br><span class="line">    mov cx,10</span><br><span class="line">    leng:</span><br><span class="line">        mov dl,01h;笑脸符号</span><br><span class="line">        mov ah,2</span><br><span class="line">        int 21h</span><br><span class="line">    loop leng</span><br><span class="line">    </span><br><span class="line">    mov dl,0dh;回车换行</span><br><span class="line">    int 21h</span><br><span class="line">    mov dl,0ah</span><br><span class="line">    int 21h</span><br><span class="line">    cli;关中断</span><br><span class="line">    Iret;中断返回</span><br><span class="line">    smiend:nop</span><br><span class="line">smile_face endp </span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="BIOS中断"><a href="#BIOS中断" class="headerlink" title="BIOS中断"></a>BIOS中断</h2><ul><li>BIOS主要有几部分：<br>  系统硬件检测和初始化程序；<br>  内中断的中断处理程序；<br>  硬件中断的中断处理程序；<br>  I&#x2F;O设备及接口控制等功能模块。</li></ul><h3 id="屏幕及光标控制-INT-10H"><a href="#屏幕及光标控制-INT-10H" class="headerlink" title="屏幕及光标控制 INT 10H"></a>屏幕及光标控制 INT 10H</h3><h4 id="光标控制"><a href="#光标控制" class="headerlink" title="光标控制"></a>光标控制</h4><p>（1）光标大小设置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AH=01H</span><br><span class="line">CH=光标开始行</span><br><span class="line">CL=光标结束行</span><br><span class="line">INT 10H</span><br></pre></td></tr></table></figure><p>（2）设置光标位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AH=02H</span><br><span class="line">DH=行号</span><br><span class="line">DL=列号</span><br><span class="line">BH=页号</span><br><span class="line">INT 10H</span><br></pre></td></tr></table></figure><p>（3）读光标位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AH=03H</span><br><span class="line">BH=页号</span><br><span class="line">INT 10H</span><br></pre></td></tr></table></figure><p>返回值：DH&#x3D;行号，DL&#x3D;列号，CX&#x3D;光标大小 </p><h4 id="卷屏、清屏、开窗口"><a href="#卷屏、清屏、开窗口" class="headerlink" title="卷屏、清屏、开窗口"></a>卷屏、清屏、开窗口</h4><p>（1）选择显示页<br>AH&#x3D;05H<br>AL&#x3D;页号<br>INT 10H<br>（2）屏幕开窗口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AH=06H</span><br><span class="line">AL=0</span><br><span class="line">BH=窗口颜色属性</span><br><span class="line">CH=左上角行号</span><br><span class="line">CL=左上角列号</span><br><span class="line">DH=右下角行号</span><br><span class="line">DL=右下角列号</span><br><span class="line">INT 10H</span><br></pre></td></tr></table></figure><p>（3）屏幕上卷</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AH=06H</span><br><span class="line">AL=上卷行数</span><br><span class="line">BH=卷入行属性</span><br><span class="line">CH=左上角行号</span><br><span class="line">CL=左上角列号</span><br><span class="line">DH=右下角行号</span><br><span class="line">DL=右下角列号   </span><br><span class="line">INT 10H</span><br></pre></td></tr></table></figure><p>（4）屏幕下卷<br>AH&#x3D;07H<br>其余同屏幕上卷</p><h4 id="字符读与显示"><a href="#字符读与显示" class="headerlink" title="字符读与显示"></a>字符读与显示</h4><p>（1）读当前光标处字符和属性<br>格式：  AH&#x3D;08H<br>     BH&#x3D;页号<br>      INT 10H<br>返回值：AH&#x3D;属性，AL&#x3D;字符<br>（2）显示多个带属性的相同字符<br>格式：  AH&#x3D;09H<br>         BH&#x3D;页号<br>         CX&#x3D;字符重复个数<br>         AL&#x3D;字符<br>         BL&#x3D;属性<br>      INT 10H<br>（3）显示多个无属性的相同字符<br>格式：AH&#x3D;0AH<br>       BH&#x3D;页号<br>       CX&#x3D;字符重复个数<br>       AL&#x3D;字符<br>       INT 10H<br>（4）显示一个字符<br>格式：AH&#x3D;0EH<br>          AL&#x3D;字符<br>          INT 10H<br>（5）显示字符串<br>格式：AH&#x3D;13H<br>       ES:BP&#x3D;字符串地址<br>     CX&#x3D;字符串长度<br>       BH&#x3D;页号<br>      AL&#x3D;0，BL&#x3D;属性，光标返回开始处<br>      AL&#x3D;1，BL&#x3D;属性，光标跟随字符移动<br>     AL&#x3D;2，要求字符和属性一起定义，光标返回开始处<br>       AL&#x3D;3，字符和属性一起定义，光标跟随字符移动<br>       INT 10H</p><h3 id="键盘中断-INT-16H"><a href="#键盘中断-INT-16H" class="headerlink" title="键盘中断 INT 16H"></a>键盘中断 INT 16H</h3><p>8086系统对键盘的处理分为两个层次。硬件接口处理（9号键盘中断）和BIOS系统键盘处理（INT 16H）。 </p><h4 id="硬件接口处理"><a href="#硬件接口处理" class="headerlink" title="硬件接口处理"></a>硬件接口处理</h4><p>当键盘上的按键按下时，通过8259A中断控制器向CPU发出9号硬件中断请求。如果此时中断允许标志位IF为1，CPU会响应此中断，转到9号硬件键盘中断处理程序去执行。 </p><h4 id="BIOS系统键盘处理"><a href="#BIOS系统键盘处理" class="headerlink" title="BIOS系统键盘处理"></a>BIOS系统键盘处理</h4><p>（1）从键盘读出一个字符<br>格式：AH&#x3D;00H<br>           INT 16H<br>返回值：AL&#x3D;字符ASCII码，AH&#x3D;扫描码。<br>功能：从键盘缓冲区队首取出字符送入AX，同时缓冲区后续字符前移。<br>（2）判断并读出键盘字符<br>格式：AH&#x3D;01H<br>           INT 16H<br>返回值：ZF&#x3D;0，AL&#x3D;字符ASCII码，AH&#x3D;扫描码；ZF&#x3D;1，缓冲区为空。<br>功能：可从ZF值判断键盘缓冲区中是否有按键字符。<br>（3）读取键盘状态<br>格式：AH&#x3D;02H<br>           INT 16H<br>返回值：AL&#x3D;键盘状态字节。<br>功能：读取控制键等特殊功能键的状态。<br>（4）软件模拟按键<br>格式：AH&#x3D;05H<br>          CL&#x3D;键的ASCII码<br>          CH&#x3D;键的扫描码<br>          INT 16H<br>功能：在键盘缓冲区队尾单元写入一个字符，模拟按键按下。 </p><h3 id="时钟中断-INT-1AH"><a href="#时钟中断-INT-1AH" class="headerlink" title="时钟中断 INT 1AH"></a>时钟中断 INT 1AH</h3><p>（1）读取时钟计数器当前值<br>格式：AH&#x3D;00H<br>           INT 1AH<br>返回值：CX&#x3D;计数值高字，DX&#x3D;计数值低字。<br>（2）设置时钟计数器<br>格式：AH&#x3D;01H<br>           CX&#x3D;计数值高字<br>           DX&#x3D;计数值低字<br>           INT 1AH<br>注意：此项操作会修改系统时钟。 </p><h2 id="DOS中断"><a href="#DOS中断" class="headerlink" title="DOS中断"></a>DOS中断</h2><h3 id="显示功能调用"><a href="#显示功能调用" class="headerlink" title="显示功能调用"></a>显示功能调用</h3><h4 id="显示一个字符"><a href="#显示一个字符" class="headerlink" title="显示一个字符"></a>显示一个字符</h4><p>格式1：AH&#x3D;02H<br>            DL&#x3D;字符<br>            INT 21H<br>功能：屏幕上显示一个字符，光标跟随字符移动。检验DL是否为Ctrl_Break。<br>格式2：AH&#x3D;06H<br>           DL&#x3D;字符<br>           INT 21H<br>功能：屏幕上显示一个字符，光标跟随字符移动。不检验Ctrl_Break。</p><h4 id="显示一串字符"><a href="#显示一串字符" class="headerlink" title="显示一串字符"></a>显示一串字符</h4><p>格式：AH&#x3D;09H<br>           DS:DX&#x3D;字符串地址<br>           INT 21H<br>功能：屏幕上显示一串字符，光标跟随字符移动。要求字符串必须以$结尾。</p><h4 id="打印一个字符"><a href="#打印一个字符" class="headerlink" title="打印一个字符"></a>打印一个字符</h4><p>格式：AH&#x3D;05H<br>           DL&#x3D;字符<br>           INT 21H<br>功能：把一个字符送到打印机上打印出来。 </p><h3 id="键盘功能调用"><a href="#键盘功能调用" class="headerlink" title="键盘功能调用"></a>键盘功能调用</h3><h4 id="键入一个字符并回显"><a href="#键入一个字符并回显" class="headerlink" title="键入一个字符并回显"></a>键入一个字符并回显</h4><p>格式：AH&#x3D;01H<br>           INT 21H<br>返回值：AL&#x3D;字符的ASCII码。</p><h4 id="键入一个字符不回显"><a href="#键入一个字符不回显" class="headerlink" title="键入一个字符不回显"></a>键入一个字符不回显</h4><p>格式1：AH&#x3D;07H<br>           INT 21H<br>返回值：AL&#x3D;字符的ASCII码。不检验键入的字符是否为Ctrl_Break。<br>格式2：AH&#x3D;08H<br>              INT 21H<br>返回值：AL&#x3D;字符的ASCII码。对键入的字符检验是否为Ctrl_Break。 </p><h4 id="键入一串字符保存到缓冲区"><a href="#键入一串字符保存到缓冲区" class="headerlink" title="键入一串字符保存到缓冲区"></a>键入一串字符保存到缓冲区</h4><p>格式：AH&#x3D;0AH<br>           DS:DX&#x3D;字节缓冲区首址<br>      INT 21H<br>要求：缓冲区的第1个字节单元为允许输入的最大字符数，第2个单元为实际键入个数，从第3个单元开始存放键入字符。</p><h4 id="读键盘状态"><a href="#读键盘状态" class="headerlink" title="读键盘状态"></a>读键盘状态</h4><p>格式：AH&#x3D;0BH<br>      INT 21H<br>返回值：有键入，AL&#x3D;0FFH；无键入，AL&#x3D;00H。</p><h4 id="清除键盘缓冲区并调用"><a href="#清除键盘缓冲区并调用" class="headerlink" title="清除键盘缓冲区并调用"></a>清除键盘缓冲区并调用</h4><p>格式：AH&#x3D;0CH<br>        AL&#x3D;功能号<br>            INT 21H<br>功能：清除键盘缓冲区的同时，调用键盘输入功能（1、7、8、10功能号）。使用此功能可以在输入一个字符之前将以前输入的字符从缓冲区清除。</p><h3 id="日期、时间功能调用"><a href="#日期、时间功能调用" class="headerlink" title="日期、时间功能调用"></a>日期、时间功能调用</h3><h4 id="读取系统日期"><a href="#读取系统日期" class="headerlink" title="读取系统日期"></a>读取系统日期</h4><p>格式：AH&#x3D;2AH<br>           INT 21H<br>返回值：CX&#x3D;年，DH&#x3D;月，DL&#x3D;日，AL&#x3D;星期。日期值为十六进制数。</p><h4 id="设置系统日期"><a href="#设置系统日期" class="headerlink" title="设置系统日期"></a>设置系统日期</h4><p>格式：AH&#x3D;2BH<br>          CX&#x3D;年<br>           DH&#x3D;月<br>           DL&#x3D;日<br>           AL&#x3D;星期<br>           INT 21H<br>返回值：AL&#x3D;00，设置成功；AL&#x3D;0FFH，无效。</p><h4 id="读取系统时间"><a href="#读取系统时间" class="headerlink" title="读取系统时间"></a>读取系统时间</h4><p>格式：AH&#x3D;2CH<br>           INT 21H<br>返回值：CH&#x3D;小时（0～23），CL&#x3D;分（0～59），DH&#x3D;秒（0～59），DL&#x3D;百分秒（0～99）。</p><h4 id="设置系统时间"><a href="#设置系统时间" class="headerlink" title="设置系统时间"></a>设置系统时间</h4><p>格式：AH&#x3D;2DH<br>      CH&#x3D;小时（0～23）<br>          CL&#x3D;分（0～59）<br>           DH&#x3D;秒（0～59）<br>           DL&#x3D;百分秒（0～99）<br>           INT 21H<br>返回值：AL&#x3D;00，设置成功；AL&#x3D;0FFH，无效。</p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编语言：多文件编程</title>
      <link href="/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B.html"/>
      <url>/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>宏定义语句MACRO和子程序定义语句PROC一样都是伪指令。宏定义需要一对伪指令MACRO和ENDM完成。<br>格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宏名字 MACRO [哑元1,哑元2,… ]  </span><br><span class="line">… </span><br><span class="line">语句串</span><br><span class="line">…</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure><p>说明：宏定义不产生目标代码。 其中哑元1，哑元2，… 是虚拟参数或形式参数，用逗号分隔。虚参或形参可不设置。</p><h3 id="宏调用"><a href="#宏调用" class="headerlink" title="宏调用"></a>宏调用</h3><p>在程序中使用宏时，只要写出<code>宏名字[实参]</code>既可。</p><h3 id="宏展开"><a href="#宏展开" class="headerlink" title="宏展开"></a>宏展开</h3><p>源程序在汇编时，宏指令被汇编程序用相应的程序代码所取代 ，这个过程称为宏展开。</p><h3 id="宏运算"><a href="#宏运算" class="headerlink" title="宏运算"></a>宏运算</h3><p>宏运算是指以特殊运算符实现不同变元的过程。<br>包括&amp;、&lt; &gt;、!、%、;; 5种运算符。</p><h4 id="amp-替换运算符"><a href="#amp-替换运算符" class="headerlink" title="&amp; 替换运算符"></a>&amp; 替换运算符</h4><p>用于将字串与哑元连接。宏调用时，字串与相应的实元内容连在一起。<br><strong>e.g.</strong> 定义字符串宏指令DISTR.。<br>宏定义：</p><p>DISTR   MACRO  SS<br>    DB   ‘Exam：&amp;SS’，0AH，0DH，’$’<br>ENDM</p><p>宏调用：<br>    DISTR book<br>宏展开：<br>    DB    ‘Exam:book’ ，0AH，0DH，’$’ </p><h4 id="lt-gt-传递运算符"><a href="#lt-gt-传递运算符" class="headerlink" title="&lt; &gt; 传递运算符"></a>&lt; &gt; 传递运算符</h4><p>在变元为字符串时，如果实元是含有空格的字符串，则实元要用&lt; &gt; 传递运算符括起来。</p><h4 id="！转义运算符"><a href="#！转义运算符" class="headerlink" title="！转义运算符"></a>！转义运算符</h4><p>当字符串中含有&lt; 或 &gt;字符时，为避免与传递运算符冲突，在宏调用的实元中用！表示该字符为普通字符。</p><h4 id="表达式运算符"><a href="#表达式运算符" class="headerlink" title="% 表达式运算符"></a>% 表达式运算符</h4><p>在宏调用的实元中如果有表达式，%运算符将表达式的值作为实元。</p><h4 id="宏注释符"><a href="#宏注释符" class="headerlink" title=";; 宏注释符"></a>;; 宏注释符</h4><p>双分号;;宏注释符是在宏定义中使用的注释符。其后的注释在宏调用及宏展开时不出现。</p><h3 id="宏标号"><a href="#宏标号" class="headerlink" title="宏标号"></a>宏标号</h3><p>格式：LOCAL  标号1  [,标号2…]<br>LOCAL指定局部标号伪指令只能在宏定义体中使用，并且是宏定义体的第一条语句。LOCAL的作用是将给出的标号在多次宏调用时以不同的数字取代标号，避免标号的重复定义。</p><h3 id="宏删除"><a href="#宏删除" class="headerlink" title="宏删除"></a>宏删除</h3><p>当不需要某个宏时，可以将其删除。<br>格式：PURGE  宏名[,宏名…]<br>说明：PURGE伪指令在汇编时将该语句中的宏定义名删除。</p><h3 id="宏库建立与调用"><a href="#宏库建立与调用" class="headerlink" title="宏库建立与调用"></a>宏库建立与调用</h3><p>将宏的宏定义部分放在扩展名为.MAC的文件中，称为宏库。<br>在应用程序中使用宏指令之前，用INCLUDE伪指令把宏库调入，然后再使用这些宏。</p><h2 id="结构伪操作"><a href="#结构伪操作" class="headerlink" title="结构伪操作"></a>结构伪操作</h2><h4 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h4><p>格式： 结构名  STRUC<br>              结构体<br>        结构名   ENDS</p><h4 id="结构预置"><a href="#结构预置" class="headerlink" title="结构预置"></a>结构预置</h4><p>把相关信息存入存储器。<br>格式：  结构变量名 结构名 &lt;字段值表&gt;<br>结构名是结构定义时的名字；&lt;字段值表&gt;用于给结构变量赋初值。<br>mem1 class &lt;1,’WANG’,’MAN’,18,89&gt;</p><h4 id="结构引用"><a href="#结构引用" class="headerlink" title="结构引用"></a>结构引用</h4><p>格式：结构变量名.结构字段名<br>说明：“．”表示对字段的访问。在使用时，可以预先将结构变量的起始地址、偏移量送往某个寄存器，再用寄存器间址代替结构变量名 。</p><h2 id="重复汇编和条件汇编"><a href="#重复汇编和条件汇编" class="headerlink" title="重复汇编和条件汇编"></a>重复汇编和条件汇编</h2><h3 id="重复汇编"><a href="#重复汇编" class="headerlink" title="重复汇编"></a>重复汇编</h3><h4 id="重复次数确定"><a href="#重复次数确定" class="headerlink" title="重复次数确定"></a>重复次数确定</h4><p>格式：REPT  重复次数n<br>         重复体<br>         ENDM<br>功能：将重复体重复n次。</p><h4 id="重复次数不确定"><a href="#重复次数不确定" class="headerlink" title="重复次数不确定"></a>重复次数不确定</h4><p>格式1：IRP  哑元，&lt;实元1，实元2，…&gt;<br>        重复体<br>        ENDM<br>功能：用实元替代哑元，重复次数由实元的个数决定。<br>格式2：IRPC 哑元，字符串<br>功能：由字符串替代哑元，重复次数由字符串的字符个数决定。<br>用IRP定义子程序现场保护功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.CODE</span><br><span class="line">IRP REG,&lt;AX,BX,CX,DX,SI,DI,BP&gt;</span><br><span class="line">PUSH REG</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure><p>汇编时，在代码段中连续插入了7条PUSH指令，分别是PUSH AX～PUSH BP。</p><h3 id="条件汇编"><a href="#条件汇编" class="headerlink" title="条件汇编"></a>条件汇编</h3><p>格式：IF  表达式<br>                代码段1<br>           ELSE<br>                代码段2<br>           ENDIF<br>例     在程序中控制某条指令是否汇编。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.CODE</span><br><span class="line"> …</span><br><span class="line">IF X EQ 0                ；汇编时，如果X单元的值等于0， </span><br><span class="line">MOV BX,0      ；这两条指令加在程序中</span><br><span class="line">MOV AL,[BX]</span><br><span class="line">ELSE      ；否则，下面两条指令加在程序中</span><br><span class="line">MOV BX,1</span><br><span class="line">MOV DL,[BX]</span><br><span class="line">ENDIF </span><br><span class="line">… </span><br></pre></td></tr></table></figure><h2 id="多模块结构"><a href="#多模块结构" class="headerlink" title="多模块结构"></a>多模块结构</h2><h3 id="全局符号定义PUBLIC"><a href="#全局符号定义PUBLIC" class="headerlink" title="全局符号定义PUBLIC"></a>全局符号定义PUBLIC</h3><p>在各个模块间共用的变量、符号、标号、过程等要用PUBLIC伪指令事先说明为全局变量，以便能被其他模块引用。<br>格式：PUBLIC 符号1[,符号2，……]<br>功能：将本模块中的符号或过程定义为全局变量，共其它模块使用。</p><h3 id="外部符号说明EXTRN"><a href="#外部符号说明EXTRN" class="headerlink" title="外部符号说明EXTRN"></a>外部符号说明EXTRN</h3><p>EXTRN伪指令用来说明某个变量、符号或过程是其它模块定义的，在本模块中需要引用。<br>格式：EXTRN  符号1:类型  [,符号2：类型，……]<br>功能：将外部符号和其类型进行说明。<br>类型为：BYTE、WORD、DWORD、NEAR、FAR等。符号的类型要与它在定义模块中的一致。 </p><h3 id="段属性与段组合"><a href="#段属性与段组合" class="headerlink" title="段属性与段组合"></a>段属性与段组合</h3><p>在定义代码段时，代码段名相同时要加 <code>PARA &#39;CODE&#39;</code>，以使其类别相同；数据段也可以用<code>PARA &#39;DATA&#39;</code> 加以说明。<br>在多模块程序设计中，最少定义一个堆栈段，一般在主模块中定义。主模块的最后一条结束伪指令<code>END START</code>必须加上标号（START），而其它模块的END语句不能带有标号。</p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编语言：子程序</title>
      <link href="/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%AD%90%E7%A8%8B%E5%BA%8F.html"/>
      <url>/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%AD%90%E7%A8%8B%E5%BA%8F.html</url>
      
        <content type="html"><![CDATA[<h2 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h2><h3 id="调用指令"><a href="#调用指令" class="headerlink" title="调用指令"></a>调用指令</h3><p>子程序调用格式：CALL 子程序名</p><ul><li>子程序与分支程序的最大区别是子程序执行完要返回到主程序，也就是返回到CALL指令的下一条继续执行。</li><li>在子程序中用RET指令作为返回指令。</li></ul><h4 id="段内调用"><a href="#段内调用" class="headerlink" title="段内调用"></a>段内调用</h4><p>（1） 段内直接调用<br>    格式：CALL OPR<br>    执行的操作：先保存断点：SP &lt;—SP-2，将CALL的下一条指令的IP入栈；再将子程序名OPR代表的偏移地址—&gt;IP，转到子程序执行。<br>    功能：子程序名直接写在指令中，作段内调用。<br>（2）段内间接调用<br>      格式：CALL WORD PTR OPR<br>      执行的操作：先将断点处的IP入栈保存；再将寄存器或存储单元中的一个字—&gt;IP。<br>      功能：子程序的偏移地址由寄存器或存储单元指出，作段内调用。</p><h4 id="段间调用"><a href="#段间调用" class="headerlink" title="段间调用"></a>段间调用</h4><p>（1） 段间直接远调用<br>    格式：CALL FAR PTR OPR<br>    执行的操作：先将CALL的下一条指令CS和IP分别入栈；再把程序的偏移地址—&gt;IP，子程序的段地址—&gt;CS。<br>    功能：子程序名用FAR PTR直接写在指令中，作跨段调用。<br>（2）段间间接调用<br>      格式：CALL DWORD PTR OPR<br>      执行的操作：先将CALL的下一条指令CS和IP分别入栈；再将存储单元(EA)—&gt;IP，(EA+2)—&gt;CS。<br>      功能：子程序地址保存在双字单元中，第一个字作为偏移地址，第二个字作为段地址，作跨段调用。</p><h3 id="返回指令"><a href="#返回指令" class="headerlink" title="返回指令"></a>返回指令</h3><p>格式： RET  [n]   </p><p>功能：用于子程序中，返回到主程序的断点处继续执行。执行时，将断点从栈中弹出，修改IP或修改IP、CS。<br>执行的操作：<br>（1）段内返回又称为近返回，弹出的断点仅修改IP；<br>（2）段间返回又称为远返回，弹出断点的偏移地址→(IP)，再弹出断点的段地址→(CS)；<br>（3）如果是RET n 指令，表示弹出断点后，再将堆栈指针SP+n之后再返回。</p><h3 id="过程定义"><a href="#过程定义" class="headerlink" title="过程定义"></a>过程定义</h3><h4 id="伪指令PROC"><a href="#伪指令PROC" class="headerlink" title="伪指令PROC"></a>伪指令PROC</h4><p>过程定义伪指令格式为：<br>    子程序名  PROC  属性<br>     ……<br>    子程序名  ENDP</p><ul><li>PROC和ENDP必须成对使用，表示子程序的开始和结束。</li><li>属性是指子程序的类型属性，分为NEAR近程属性和FAR远程属性。属性隐含为NEAR型。</li></ul><h3 id="现场保护"><a href="#现场保护" class="headerlink" title="现场保护"></a>现场保护</h3><p>在进入子程序时，把某些主程序需要用到的寄存器保存起来，称为现场保护。一般采用PUSH指令入栈保存的方法。<br>在子程序返回主程序之前，将堆栈中保存的内容用POP指令弹出到相关的寄存器中，称为恢复现场。</p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编：循环指令</title>
      <link href="/8086%E6%B1%87%E7%BC%96%EF%BC%9A%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4.html"/>
      <url>/8086%E6%B1%87%E7%BC%96%EF%BC%9A%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4.html</url>
      
        <content type="html"><![CDATA[<h2 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h2><ul><li>格式： LOOP  OPR<br>  执行的操作：(CX)&#x3D;(CX)-1，若CX≠0，跳转到标号OPR处循环执行，CX&#x3D;0则执行LOOP的下一条指令。</li><li>格式： LOOPZ&#x2F;LOOPE  OPR<br>  执行的操作：(CX)&#x3D;(CX)-1，若CX≠0，并且ZF&#x3D;1则跳转到标号OPR处循环执行，若CX&#x3D;0，或者ZF&#x3D;0则执行LOOP的下一条指令。<br>  说明：结果为0或相等循环。</li><li>格式： LOOPNZ&#x2F;LOOPNE  OPR<br>  执行的操作：(CX)&#x3D;(CX)-1，若CX≠0，并且ZF&#x3D;0则跳转到标号OPR处循环执行，若CX&#x3D;0，或者ZF&#x3D;1则执行LOOP的下一条指令。<br>  说明：结果不为0或不相等循环。</li></ul><h2 id="串处理"><a href="#串处理" class="headerlink" title="串处理"></a>串处理</h2><h3 id="串传送"><a href="#串传送" class="headerlink" title="串传送"></a>串传送</h3><p>格式：MOVS  DST,  SRC<br>    MOVSB<br>    MOVSW            ;ES:[DI] &lt;— DS:[SI] </p><ul><li>和rep连用时以字节或字的形式重复传送，直到cx为0为止。</li><li>串传送方向由方向标志DF指出。若DF&#x3D;0，SI和DI自动加1（字节单元）或自动加2（字单元）；若DF&#x3D;1，SI和DI自动减量。</li><li>CLD指令使DF&#x3D;0，STD指令使DF&#x3D;1.</li></ul><h3 id="串比较"><a href="#串比较" class="headerlink" title="串比较"></a>串比较</h3><p>格式：CMPS  DST,  SRC<br>     CMPSB<br>     CMPSW</p><ul><li>分别从源串和目的串中逐个取出字节（字）数据做相减操作，结果不回送，根据比较结果改变标志位。</li><li>源串的偏移地址由SI寄存器指出，目的串的偏移地址由DI寄存器指出，比较次数有CX指出。</li><li>REPZ&#x2F;REPE前缀功能：结果为0或相等则重复操作。若CX≠0，且ZF&#x3D;1，则重复，(CX)&#x3D;(CX)-1，直到CX&#x3D;0。如果结果不为0或者不相等，退出重复操作，此时CX还没有减为0，SI和DI已经增量。</li><li>REPNZ&#x2F;REPNE前缀功能：结果不为0或不相等则重复操作.</li></ul><h3 id="串扫描"><a href="#串扫描" class="headerlink" title="串扫描"></a>串扫描</h3><p>格式：SCAS  DST<br>     SCASB<br>     SCASW</p><ul><li>在目的串DST中查找与AL或AX相同（或不相同）的字节或字，结果不保存，根据查找结果改变标志位。</li><li>目的串在附加段中，偏移地址由DI寄存器指出，扫描次数由CX指出。</li><li>每扫描一次，DI自动增量或减量，CX减1；</li><li>和重复前缀REPZ&#x2F;REPE或REPNZ&#x2F;REPNE连用。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extra segment</span><br><span class="line">value  dw  1,2,0,3,5,-1,10</span><br><span class="line">addr1  dw  ?</span><br><span class="line">extra ends</span><br><span class="line">code segment</span><br><span class="line">assume cs:code,es:extra</span><br><span class="line">start:</span><br><span class="line">mov ax,extra</span><br><span class="line">mov es,ax</span><br><span class="line">mov ax,-1</span><br><span class="line">lea di,value</span><br><span class="line">cld</span><br><span class="line">mov cx,addr1-value</span><br><span class="line">shr cx,1</span><br><span class="line">repnz scasw</span><br><span class="line">sub di,2</span><br><span class="line">mov addr1,di</span><br><span class="line">mov ah,4ch</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li></ul><h3 id="串获取"><a href="#串获取" class="headerlink" title="串获取"></a>串获取</h3><p>格式：LODS　SRC<br>      LODSB<br>      LODSW</p><ul><li>从源串SRC中取出一字节或字，放入AL或AX中。</li><li>源串在数据段定义，偏移地址由SI指出。</li><li>如果与REP连用，则连续取出字节或字。取出次数由CX指出。</li></ul><h3 id="串存入"><a href="#串存入" class="headerlink" title="串存入"></a>串存入</h3><p>格式：STOS  DST<br>       STOSB<br>       STOSW</p><ul><li>将AL或AX内容存入附加段的目的串中。</li><li>目的串中附加段定义，偏移地址由DI指出。</li><li>如果与REP连用，则将AL或AX中的内容连续存入目的串。存入次数由CX指出。</li></ul><h2 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h2><p>冒泡排序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">    part dw 15,32,6,-27,8</span><br><span class="line">    sign  dw  ?</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov cx,sign-part;数组长度</span><br><span class="line">    shr cx,1 ;元素个数</span><br><span class="line">    dec cx</span><br><span class="line"></span><br><span class="line">    loop1:</span><br><span class="line">        push cx;保存外循环次数</span><br><span class="line">        mov bx,0</span><br><span class="line">        loop2:</span><br><span class="line">            mov ax,part[bx]</span><br><span class="line">            cmp ax,part[bx+2]</span><br><span class="line">            jle next;升序</span><br><span class="line">                xchg ax,part[bx+2];交换</span><br><span class="line">                mov part[bx],ax</span><br><span class="line">            next: </span><br><span class="line">                add bx,2</span><br><span class="line">        loop loop2</span><br><span class="line">        pop cx;恢复外循环次数</span><br><span class="line">    loop loop1</span><br><span class="line"></span><br><span class="line">    mov ah,4ch</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编：分支指令</title>
      <link href="/8086%E6%B1%87%E7%BC%96%EF%BC%9A%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4.html"/>
      <url>/8086%E6%B1%87%E7%BC%96%EF%BC%9A%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4.html</url>
      
        <content type="html"><![CDATA[<h2 id="与分支有关的指令"><a href="#与分支有关的指令" class="headerlink" title="与分支有关的指令"></a>与分支有关的指令</h2><h3 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP OPR</span><br><span class="line">JMP SHORT OPR</span><br><span class="line">JMP NEAR PTR OPR</span><br><span class="line">JMP WORD PTR OPR</span><br><span class="line">JMP FAR PTR OPR</span><br><span class="line">JMP DWORD PTR OPR</span><br></pre></td></tr></table></figure><h3 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><h4 id="根据条件标志转移"><a href="#根据条件标志转移" class="headerlink" title="根据条件标志转移"></a>根据条件标志转移</h4><p>格式：<code>转移指令操作码  OPR</code></p><ul><li>JZ（或JE）    结果为0（或相等）则转移       测试条件：ZF&#x3D;1</li><li>JNZ（或JNE）  结果不为0（或不相等）则转移测试条件：ZF&#x3D;0 </li><li>JC             结果有进位则转移                                  测试条件：CF&#x3D;1 </li><li>JNC                结果无进位则转移                                             测试条件：CF&#x3D;0</li><li>JS      结果为负则转移                                                                测试条件：SF&#x3D;1 </li><li>JNS    结果为正则转移                                                             测试条件：SF&#x3D;0</li><li>JO     结果溢出则转移     测试条件：OF&#x3D;1 </li><li>JNO    结果不溢出则转移      测试条件：OF&#x3D;0</li><li>JP       结果为偶数个1则转移    测试条件：PF&#x3D;1</li><li>JNP    结果为奇数个1则转移    测试条件：PF&#x3D;0</li></ul><h4 id="无符号数比较转移"><a href="#无符号数比较转移" class="headerlink" title="无符号数比较转移"></a>无符号数比较转移</h4><p>无符号数比较转移指令包括4种指令：</p><ul><li>JB 低于则转移 （A＜B）测试条件：CF &#x3D;1且ZF&#x3D;0</li><li>JBE        低于等于则转移（A≤B） 测试条件：CF&#x3D;1或ZF&#x3D;1 </li><li>JA 高于则转移 （A＞B）测试条件：CF&#x3D;0且ZF&#x3D;0 </li><li>JAE        高于等于则转移       （A≥B） 测试条件：CF&#x3D;0或ZF&#x3D;1</li></ul><h4 id="带符号数比较转移"><a href="#带符号数比较转移" class="headerlink" title="带符号数比较转移"></a>带符号数比较转移</h4><p>带符号数的最高位为符号位,因此带符号数的数值与无符号数不一样 </p><ul><li>JL小于则转移 （A＜B）测试条件：SF≠OF且ZF&#x3D;0 </li><li>JLE           小于等于则转移（A≤B）测试条件： SF≠OF或ZF&#x3D;1  </li><li>JG大于则转移  （A＞B）测试条件：SF&#x3D;OF且ZF&#x3D;0 </li><li>JGE       大于等于则转移（A≥B）测试条件：SF&#x3D;OF或ZF&#x3D;1</li></ul><h4 id="CX值为0则转移"><a href="#CX值为0则转移" class="headerlink" title="CX值为0则转移"></a>CX值为0则转移</h4><p>格式： <code>JCXZ OPR</code><br>测试条件：(CX)&#x3D;0<br>功能：测试CX的值为0则转移。</p><h3 id="测试指令TEST"><a href="#测试指令TEST" class="headerlink" title="测试指令TEST"></a>测试指令TEST</h3><p>格式： <code>TEST OPR1,OPR2</code><br>功能：两个操作数相与,结果不回送,改变标志位。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AL,35H;00110101</span><br><span class="line">TEST  AL,08H;00001000</span><br><span class="line">JZ  LET1</span><br><span class="line">NOT  AL</span><br><span class="line">JMP  OUT1</span><br><span class="line">LET1:</span><br><span class="line">ADD  AL,3</span><br><span class="line">OUT1:</span><br><span class="line">MOV  Y,AL</span><br></pre></td></tr></table></figure><h4 id="数字和字母的判断"><a href="#数字和字母的判断" class="headerlink" title="数字和字母的判断"></a>数字和字母的判断</h4><p>数字的ASCII码：30H～39H 00110000B～00111001B<br>大写字母的ASCII码：41H～5AH  01000001B～01011010B<br>小写字母的ASCII码：61H～7AH            01100001B～01111010B</p><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><h4 id="算术移位操作（带符号）"><a href="#算术移位操作（带符号）" class="headerlink" title="算术移位操作（带符号）"></a>算术移位操作（带符号）</h4><p>（1）SAL算术左移指令<br>格式： <code>SAL  OPR, CNT</code><br>功能：操作数左移,最高位移入CF,最低位补0。CNT&gt;1,则用CL寄存器存放次数。<br>（2） SAR算术右移指令<br>格式： <code>SAR  OPR, CNT</code><br>功能：操作数右移,最低位移入CF,最高有效位右移的同时最高有效位保持不变。即如果原来是0则仍为0,原来是1,则仍为1。若CNT&gt;1,则用CL寄存器存放次数 。</p><h4 id="逻辑移位操作（无符号）"><a href="#逻辑移位操作（无符号）" class="headerlink" title="逻辑移位操作（无符号）"></a>逻辑移位操作（无符号）</h4><p>（1）SHL逻辑左移指令<br>格式： <code>SHL  OPR,CNT</code><br>功能：与算术左移一样。操作数左移,最高位移入CF,最低位补0。<br>（2）SHR逻辑右移指令<br>格式： <code>SHR  OPR,CNT</code></p><h4 id="循环移位操作"><a href="#循环移位操作" class="headerlink" title="循环移位操作"></a>循环移位操作</h4><p>（1）ROL循环左移指令<br>格式： <code>ROL  OPR,CNT</code><br>功能：操作数循环左移,最高位移入CF同时移入最低位。<br>（2）ROR循环右移指令<br>格式：<code>ROR  OPR,CNT</code><br>功能：操作数循环右移,最低位移入CF同时移入最高位。<br>（3）RCL带进位的循环左移指令<br>格式： <code>RCL  OPR,CNT</code><br>功能：操作数和进位一起循环左移,CF移入最低位同时最高位移入CF。<br>（4）RCR带进位的循环右移指令<br>格式： <code>RCR  OPR,CNT</code><br>功能：操作数和进位一起循环右移,CF移入最高位同时最低位移入CF。</p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编：基本汇编指令</title>
      <link href="/8086%E6%B1%87%E7%BC%96%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4.html"/>
      <url>/8086%E6%B1%87%E7%BC%96%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4.html</url>
      
        <content type="html"><![CDATA[<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><h3 id="段定义伪指令"><a href="#段定义伪指令" class="headerlink" title="段定义伪指令"></a>段定义伪指令</h3><p>段定义伪指令可用来定义各种类型的段。<br>格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">段名  SEGMENT  [类型参数]</span><br><span class="line">段名  ENDS</span><br></pre></td></tr></table></figure><p>SEGMENT和ENDS必须成对使用，表示段的开始和结束。</p><h3 id="ASSUME伪指令"><a href="#ASSUME伪指令" class="headerlink" title="ASSUME伪指令"></a>ASSUME伪指令</h3><p>ASSUME伪指令用于指明段寄存器与段的对应关系，格式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME 段寄存器:段名,[段寄存器:段名,…]</span><br></pre></td></tr></table></figure><p>如果不使用ASSUME伪指令，系统就无法获知用户定义的段都有哪些，进而就不能正确地划分段。</p><h3 id="数据定义伪指令"><a href="#数据定义伪指令" class="headerlink" title="数据定义伪指令"></a>数据定义伪指令</h3><p>数据定义伪指令格式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[存储单元名]  DB（或DW、DD等伪指令） 操作数</span><br></pre></td></tr></table></figure><p>其中：<br>（1）存储单元可以起名也可以不要名字<br>（2）数据定义伪指令<br>            DB      定义字节单元<br>            DW    定义字单元<br>            DD    定义双字单元<br>            DQ    定义四字单元<br>            DT    定义十字节单元</p><ul><li>操作数用于指出存储单元的内容即该单元的值。 </li><li>一条数据定义伪指令可以给多个存储单元赋值。</li><li>确定存储单元的内容时要与存储单元的属性一致。</li></ul><h3 id="赋值伪指令"><a href="#赋值伪指令" class="headerlink" title="赋值伪指令"></a>赋值伪指令</h3><ul><li>在程序中多次出现同一个表达式时，可以用EQU定义一个符号来代表表达式，以简化书写。</li><li>与EQU伪操作相似，等号 &#x3D; 伪操作也可以给表达式赋值(只能是数值表达式)，允许对一个符号多次重复定义；而EQU则不允许。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONT EQU 125*3.14</span><br><span class="line">STR EQU &#x27;RIGHT&#x27;</span><br><span class="line">SUM EQU 0</span><br><span class="line">BUFF=56</span><br><span class="line">PASS=2034H</span><br><span class="line">BUFF=56H</span><br></pre></td></tr></table></figure></li></ul><h3 id="设置偏移地址伪指令"><a href="#设置偏移地址伪指令" class="headerlink" title="设置偏移地址伪指令"></a>设置偏移地址伪指令</h3><p>当前的偏移地址可以用ORG伪指令定义。</p><p>如果用在数据段中，该指令可以确定存储单元的偏移地址，例如将X单元的偏移地址定义为0020H，该单元的内容为5，即(DS:0020H)&#x3D;5。伪指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA  SEGMENT</span><br><span class="line">ORG  0020H</span><br><span class="line">X DW 5</span><br><span class="line">DATA  ENDS</span><br></pre></td></tr></table></figure><p>如果用在代码段中，可从指定的单元开始存放并执行指令。<br>例如从代码段的100H开始执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORG 100H</span><br><span class="line">START:MOV AX,X      ;标号START设置为100H</span><br><span class="line">MOV BX,Y</span><br><span class="line">ADD AX,BX</span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="回送偏移地址值OFFSET"><a href="#回送偏移地址值OFFSET" class="headerlink" title="回送偏移地址值OFFSET"></a>回送偏移地址值OFFSET</h4><p> <code>MOV BX, OFFSET X            ;将X单元的偏移地址传送给BX</code><br> <code>MOV AX, OFFSET START        ;将标号START的偏移地址传送给AX</code></p><h4 id="回送段地址值SEG"><a href="#回送段地址值SEG" class="headerlink" title="回送段地址值SEG"></a>回送段地址值SEG</h4><p><code>MOV BX,SEG X             ;将X单元的段地址传送给BX</code><br><code>MOV AX, SEG START          ;将标号START的段地址传送给AX</code></p><h4 id="类型回送操作符TYPE"><a href="#类型回送操作符TYPE" class="headerlink" title="类型回送操作符TYPE"></a>类型回送操作符TYPE</h4><p><code>MOV BX,TYPE X          ;如果X是字节单元，则回送值为1，即  BX←1；</code><br><code>                       ;若是字单元，值为2，双字单元，值为4</code></p><h4 id="属性操作符PTR"><a href="#属性操作符PTR" class="headerlink" title="属性操作符PTR"></a>属性操作符PTR</h4><p><code>MOV BYTE PTR [BX],10       ；定义目的操作数为字节单元</code><br><code>MOV WORD PTR [SI],20      ；定义目的操作数为字单元</code></p><h4 id="类型操作符LABEL"><a href="#类型操作符LABEL" class="headerlink" title="类型操作符LABEL"></a>类型操作符LABEL</h4><p><code>X  LABEL BYTE          ;X单元的类型定义为BYTE字节型，也可以定义为WORD字型、DWORD双字型等</code></p><h2 id="基本汇编指令"><a href="#基本汇编指令" class="headerlink" title="基本汇编指令"></a>基本汇编指令</h2><h3 id="数据、栈及查表"><a href="#数据、栈及查表" class="headerlink" title="数据、栈及查表"></a>数据、栈及查表</h3><h4 id="MOV传送指令"><a href="#MOV传送指令" class="headerlink" title="MOV传送指令"></a>MOV传送指令</h4><p>MOV传送指令是双操作数指令，SRC为源操作数、DST为目的操作数。<br>格式：<code>MOV DST,SRC</code></p><p><strong>MOV指令用法：</strong></p><ul><li>MOV 寄存器，寄存器        <code>MOV AX, BX</code></li><li>MOV寄存器，立即数         <code>MOV AX, 20</code></li><li>MOV 寄存器，存储单元    <code>MOV AX, [BX]</code></li><li>MOV 寄存器，段寄存器    <code>MOV AX, CS</code></li><li>MOV 存储单元，寄存器    <code>MOV [DI], BX</code></li><li>MOV存储单元，立即数    <code>MOV WORD PTR[BI][DI], 28</code></li><li>MOV 存储单元，段寄存器    <code>MOV [BP], DS</code></li><li>MOV 段寄存器，寄存器         <code>MOV DS, AX</code></li><li>MOV段寄存器，存储单元      <code>MOV SS, [BX]</code></li></ul><p>下面列出的指令是非法的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,BL           ;操作数类型不匹配</span><br><span class="line">MOV 1234H , CX      ;目的操作数不能是立即数</span><br><span class="line">MOV [BX],[SI]       ;两个操作数不能都是存储单元</span><br><span class="line">MOV [BX],20         ;目的操作数属性不确定</span><br><span class="line">MOV CS,AX           ;CS不允许赋值</span><br><span class="line">MOV DS,1000 H       ;DS、ES、SS等段寄存器不允许用立即数赋值</span><br></pre></td></tr></table></figure><h4 id="数据交换指令XCHG"><a href="#数据交换指令XCHG" class="headerlink" title="数据交换指令XCHG"></a>数据交换指令XCHG</h4><p>XCHG指令是双操作数指令，功能是将两个操作数的内容互换。要求必须有一个操作数是寄存器，而且两个操作数的属性必须一致。操作数不能为立即数。<br>格式：&#96;XCHG  OPR1,OPR2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XCHG  AX,BX     ;寄存器AX和BX的内容互换</span><br><span class="line">XCHG  [BX],AL   ;AL寄存器的内容和字节型存储单元的内容互换</span><br><span class="line">XCHG  CX,X[SI]  ;CX寄存器的内容和字型存储单元的内容互换</span><br></pre></td></tr></table></figure><h4 id="进栈和出栈指令"><a href="#进栈和出栈指令" class="headerlink" title="进栈和出栈指令"></a>进栈和出栈指令</h4><p> <code>PUSH  SRC</code><br> <code>POP  DST</code></p><h4 id="查表转换指令XLAT"><a href="#查表转换指令XLAT" class="headerlink" title="查表转换指令XLAT"></a>查表转换指令XLAT</h4><p>格式：<code>XLAT</code></p><ul><li>使用 <code>AL</code> 的值作为偏移量，从查找表的基址 <code>BX</code> 开始计算内存地址 <code>BX + AL</code>。</li><li>将内存地址 <code>BX + AL</code> 处的字节值加载到 <code>AL</code> 中。</li></ul><h3 id="逻辑地址的获得"><a href="#逻辑地址的获得" class="headerlink" title="逻辑地址的获得"></a>逻辑地址的获得</h3><h4 id="LEA有效地址传送指令（Load-Effective-Address）"><a href="#LEA有效地址传送指令（Load-Effective-Address）" class="headerlink" title="LEA有效地址传送指令（Load Effective Address）"></a>LEA有效地址传送指令（Load Effective Address）</h4><p>格式：<code>LEA 寄存器,存储单元</code><br>功能：将存储单元的有效地址传送给寄存器。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEA  BX，TABLE</span><br><span class="line">LEA  DX，[BX]</span><br><span class="line">LEA  BX，COUNT[SI]</span><br></pre></td></tr></table></figure><h4 id="LDS-Load-DS-数据段地址传送指令"><a href="#LDS-Load-DS-数据段地址传送指令" class="headerlink" title="LDS(Load DS)数据段地址传送指令"></a>LDS(Load DS)数据段地址传送指令</h4><p>格式：<code>LDS 寄存器,双字存储单元</code><br>功能：将双字单元中保存的低字送入寄存器，高字传送给DS数据段寄存器。</p><h4 id="LES-Load-ES-附加段地址传送指令"><a href="#LES-Load-ES-附加段地址传送指令" class="headerlink" title="LES(Load ES)附加段地址传送指令"></a>LES(Load ES)附加段地址传送指令</h4><p>格式：<code>LES 寄存器,双字存储单元</code><br>功能：将双字单元中保存的低字送入寄存器，高字传送给ES附加段寄存器。</p><h3 id="算术运算类指令"><a href="#算术运算类指令" class="headerlink" title="算术运算类指令"></a>算术运算类指令</h3><h4 id="加法类"><a href="#加法类" class="headerlink" title="加法类"></a>加法类</h4><ul><li>ADD加法指令<br>  格式：<code>ADD  DST,SRC</code></li><li>ADC带进位加法指令(Add with Carry)<br>  格式：<code>ADC  DST,SRC</code><br>  源操作数加上目的操作数再加上进位标志CF，结果放入目的操作数DST。</li><li>INC加1指令(Increase 1)<br>  格式：<code>INC  OPR</code><br>  不影响CF，但影响其它状态标志位。</li></ul><h4 id="减法类"><a href="#减法类" class="headerlink" title="减法类"></a>减法类</h4><ul><li>SUB减法指令(Substract)<br>  <code>格式：SUB  DST,SRC</code></li><li>SBB带借位减法指令(Substract with Borrow)<br>  格式：<code>SBB  DST,SRC</code><br>  功能：目的操作数减去源操作数后再减去进位标志CF，结果放入目的操作数DST。</li><li>DEC减1指令(Decrease 1)<br>  格式：<code>DEC  OPR</code><br>  功能：将操作数OPR减1</li><li>NEG求补指令(Negative)<br>  格式：<code>NEG  OPR</code><br>  功能：将操作数求反加1。即求补操作，对正数的补码求补变为其负数的补码，对负数的补码求补变为其正数的补码。<br>  利用NEG指令可以求负数的绝对值。 </li><li>CMP比较指令<br>  格式：<code>CMP OPR1,OPR2</code><br>  功能：将两个操作数作相减运算，结果不回送，改变标志位。通常后跟条件转移指令，根据CMP比较之后标志位的值进行转移。</li></ul><h4 id="乘法类"><a href="#乘法类" class="headerlink" title="乘法类"></a>乘法类</h4><ul><li>MUL无符号数乘法指令<br>  （1）字节乘法<br>  格式：MUL  SRC<br>  功能：(AX)←(AL)×(SRC)<br>  （2）字乘法<br>  格式：MUL  SRC<br>  功能：(DX、AX) )←(AX)×(SRC)</li><li>IMUL带符号数乘法指令<br>  执行带符号数乘法指令时，系统将把操作数作为补码进行运算。</li><li>DIV无符号数除法指令<br>  （1）字节除法<br>  格式：DIV  SRC<br>  功能：(AL)←(AX)／(SRC)的商       (AH)←(AX)／(SRC)的余数<br>  （2）字除法<br>  格式：DIV  SRC<br>  功能：(AX)←(DX、AX)／(SRC)的商     (DX)←(DX、AX)／(SRC)的余数</li><li>IDIV带符号数除法指令</li></ul><h2 id="屏幕显示和键盘输入"><a href="#屏幕显示和键盘输入" class="headerlink" title="屏幕显示和键盘输入"></a>屏幕显示和键盘输入</h2><h3 id="DOS功能调用"><a href="#DOS功能调用" class="headerlink" title="DOS功能调用"></a>DOS功能调用</h3><p>键盘输入1个字符：      01号DOS功能调用<br>显示器输出1个字符： 02号DOS功能调用<br>    <code>AH=2</code><br>    <code>DL=字符</code><br>    <code>INT 21H</code><br>    功能：输出DL中的一个字符到显示器的光标处。</p><p>键盘输入缓冲区：       0AH号DOS功能调用<br>    键盘输入字符串<br>    格式：<code>AH=10</code><br>        <code>DS:DX=字节缓冲区首址</code><br>        <code>INT 21H</code><br>    说明：定义缓冲区的第1个字节单元为允许输入的最大字符数，第2个单元为实际键入个数（由系统自动填入），从第3个单元开始存放键入字符。<br>    功能：从键盘输入一串ASCII字符到缓冲区，用“回车”结束输入。若输入字符超过缓冲区能容纳的个数，则系统忽略此字符并响铃警告。 </p><p>显示字符串：                 09号DOS功能调用<br>    显示字符串<br>    格式：<code>AH=9</code><br>        <code>DS:DX=字符串地址</code><br>        <code>INT 21H</code><br>    功能：显示一个以“$”结尾的ASCⅡ码字符串。 </p><p>返回DOS控制：          4CH号DOS功能调用</p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编：调试工具DEBUG</title>
      <link href="/8086%E6%B1%87%E7%BC%96%EF%BC%9A%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7DEBUG.html"/>
      <url>/8086%E6%B1%87%E7%BC%96%EF%BC%9A%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7DEBUG.html</url>
      
        <content type="html"><![CDATA[<h2 id="调试工具DEBUG"><a href="#调试工具DEBUG" class="headerlink" title="调试工具DEBUG"></a>调试工具DEBUG</h2><p>DEBUG的提示符是小短线－ ，在其后输入命令。</p><h3 id="R-Register-命令——查看和修改寄存器"><a href="#R-Register-命令——查看和修改寄存器" class="headerlink" title="R(Register)命令——查看和修改寄存器"></a>R(Register)命令——查看和修改寄存器</h3><p>R命令有两种用法：</p><ul><li>直接键入R，将显示CPU所有的寄存器和标志位；</li><li>修改寄存器：在R后跟写寄存器名，则先显示寄存器的内容，在冒号后可键入新的值 。</li></ul><h3 id="D-Dump-命令——查看内存单元"><a href="#D-Dump-命令——查看内存单元" class="headerlink" title="D(Dump)命令——查看内存单元"></a>D(Dump)命令——查看内存单元</h3><p>用D命令可以查看存储单元的地址和内容。</p><p>例如：<br>  D DS:0           查看数据段，从0号单元开始<br>  D ES:0       查看附加段，从0号单元开始<br>  D DS:100       查看数据段，从100H号单元开始<br>  D 0200:5 15   查看0200H段的5号单元到15H号单元</p><h3 id="E-Enter-命令——修改内存单元"><a href="#E-Enter-命令——修改内存单元" class="headerlink" title="E(Enter)命令——修改内存单元"></a>E(Enter)命令——修改内存单元</h3><p>用E命令可以改写多个存储单元的内容。格式为：E 起始地址  修改值 修改值 …</p><p>例如：将数据段中的0B05:3 ～0B05:5 三个单元的内容修改为14、15、16。命令为<br>   E DS:3 14 15 16<br>再如：<br>   E 10           修改当前数据段10H号单元内容<br>   E ES:100    修改附加段100H号单元内容</p><h3 id="U-Unassemble-命令-——反汇编"><a href="#U-Unassemble-命令-——反汇编" class="headerlink" title="U(Unassemble)命令 ——反汇编"></a>U(Unassemble)命令 ——反汇编</h3><p>多次键入U，可连续显示后面的程序部分。<br>U后跟偏移地址，则从该地址开始反汇编。如：<br>  U 0     从代码段0号单元开始反汇编<br>  U100   从代码段100H号单元开始反汇编</p><h3 id="A-Assemble-命令——输入汇编指令"><a href="#A-Assemble-命令——输入汇编指令" class="headerlink" title="A (Assemble)命令——输入汇编指令"></a>A (Assemble)命令——输入汇编指令</h3><p>在DEBUG中，使用A命令可以输入汇编指令，系统自动地将键入的汇编指令翻译成机器代码，并相继地存放在从指定地址开始的存储区中。</p><p>由于DEBUG下的数值默认为十六进制数，因此先要将十进制数转换成十六进制数。</p><h3 id="T-x2F-P-Trace-x2F-Proceed-命令——单步执行"><a href="#T-x2F-P-Trace-x2F-Proceed-命令——单步执行" class="headerlink" title="T&#x2F;P(Trace&#x2F;Proceed)命令——单步执行"></a>T&#x2F;P(Trace&#x2F;Proceed)命令——单步执行</h3><p>先查看指令指针寄存器IP的值是否为0100，如果不是，用R IP命令修改为0100。表示现在要从CS:0100单元开始执行指令 。<br><code>-T</code><br>T命令还可以连续执行多条指令。如上例中连续执行3条指令，可用如下T命令：<br><code>-T 3</code><br>T命令也可以设置开始地址和执行条数。如上例中从0100H开始连续执行3条指令，可用如下T命令：<br><code>-T =0100  3</code></p><h3 id="G-Go-命令——连续执行程序"><a href="#G-Go-命令——连续执行程序" class="headerlink" title="G(Go)命令——连续执行程序"></a>G(Go)命令——连续执行程序</h3><h3 id="Q-Quit-命令-——退出DEBUG"><a href="#Q-Quit-命令-——退出DEBUG" class="headerlink" title="Q(Quit)命令 ——退出DEBUG"></a>Q(Quit)命令 ——退出DEBUG</h3><p>  键入Q，回车后退出DEBUG，返回到DOS下。</p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编：8086寄存器组</title>
      <link href="/8086%E6%B1%87%E7%BC%96%EF%BC%9A8086%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84.html"/>
      <url>/8086%E6%B1%87%E7%BC%96%EF%BC%9A8086%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84.html</url>
      
        <content type="html"><![CDATA[<h2 id="8086寄存器组"><a href="#8086寄存器组" class="headerlink" title="8086寄存器组"></a>8086寄存器组</h2><h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p>数据寄存器：包括AX、BX、CX、DX四个16位的通用寄存器。<br>AX（Accumulator）: 作为累加器用，算术运算 的主要寄存器<br>BX（Base）: 基址寄存器<br>CX（Count）: 计数器<br>DX（Data）: 双精度运算时与AX一起存放双操作数。其中DX存放高字（高16位），AX存放低字（低16位）。</p><p>数据寄存器中每个寄存器又可以分为2个8位的寄存器。分别为AH、AL，BH、BL，CH、CL，DH、DL。AH为高字节（高8位）寄存器、AL为低字节（低8位）寄存器。</p><h3 id="地址寄存器"><a href="#地址寄存器" class="headerlink" title="地址寄存器"></a>地址寄存器</h3><p>SI(Source Index)  源变址寄存器，可用于存放源缓冲区的偏移地址。<br>DI(Destination Index)  目的变址寄存器，可用于存放目的缓冲区的偏移地址。<br>SP(Stack Pointer)  堆栈指针寄存器，用于指出堆栈区的栈顶的偏移地址。<br>BP(Base Pointer)  基址指针寄存器，用于指出堆栈区的某个单元的偏移地址。</p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>CS (Code Segment) 代码段寄存器，用于指出存放程序的代码段的段地址。<br>DS (Data Segment)  数据段寄存器，用于指出存放数据的数据段的段地址。<br>ES (Extra Segment)  附加段寄存器，用于指出存放附加数据的附加段的段地址。<br>SS (Stack Segment) 堆栈段寄存器，用于指出堆栈区的堆栈段的段地址。</p><h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p>IP (Instruction Pointer)指令指针寄存器：用来存放代码段中的偏移地址，指出当前正在执行指令的下一条指令所在单元的偏移地址。<br>FLAGS标志寄存器：其中的某位代表CPU的一个标志，表示CPU的某种执行状态。</p><h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><table><thead><tr><th>标志位</th><th>标志</th><th>值为1</th><th>值为0</th></tr></thead><tbody><tr><td>进位标志</td><td>CF（Carry Flag）</td><td>CY</td><td>CN</td></tr><tr><td>符号标志</td><td>SF（Symbol Flag）</td><td>NG</td><td>PL</td></tr><tr><td>零标志</td><td>ZF（Zero Flag）</td><td>ZR</td><td>NZ</td></tr><tr><td>溢出标志</td><td>OF（Overflow Flag）</td><td>OV</td><td>NV</td></tr><tr><td>辅助进位标志</td><td>AF（Assistant Flag）</td><td>AC</td><td>NA</td></tr><tr><td>奇偶标志</td><td>PF（Parity Flag）</td><td>PE</td><td>PO</td></tr><tr><td>方向标志</td><td>DF（Direction Flag）</td><td>DN</td><td>UP</td></tr><tr><td>中断标志</td><td>IF ( Interrupt Flag)</td><td>EI</td><td>DI</td></tr></tbody></table><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>物理地址&#x3D;段地址×10H+偏移地址</p><h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><p>8086汇编语言中把逻辑段分为四种类型，分别是代码段、数据段、附加段和堆栈段。<br>各段的逻辑地址对应表：</p><table><thead><tr><th>段名</th><th>段寄存器</th><th>偏移地址</th></tr></thead><tbody><tr><td>代码段</td><td>CS</td><td>IP</td></tr><tr><td>数据段</td><td>DS</td><td>BX、SI、DI等地址寄存器</td></tr><tr><td>附加段</td><td>ES</td><td>BX、SI、DI等地址寄存器</td></tr><tr><td>堆栈段</td><td>SS</td><td>SP或BP</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt创建新文件报错</title>
      <link href="/Qt%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99.html"/>
      <url>/Qt%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99.html</url>
      
        <content type="html"><![CDATA[<p>使用Qt Creator创建新文件后，可能出现一系列不影响编译的报错，包括一些Qt特有的类库。</p><p>解决办法：点击构建套件中的release，清除报错信息，再重新构建即可。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中print()函数的使用</title>
      <link href="/python%E4%B8%AD%E7%9A%84%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0.html"/>
      <url>/python%E4%B8%AD%E7%9A%84%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="print-函数的使用"><a href="#print-函数的使用" class="headerlink" title="print()函数的使用"></a>print()函数的使用</h1><h2 id="print-函数可以输出哪些内容？"><a href="#print-函数可以输出哪些内容？" class="headerlink" title="print()函数可以输出哪些内容？"></a>print()函数可以输出哪些内容？</h2><ul><li>数字</li><li>字符串</li><li>含有运算符的表达式</li></ul><h2 id="print-函数可以输出到哪里？"><a href="#print-函数可以输出到哪里？" class="headerlink" title="print()函数可以输出到哪里？"></a>print()函数可以输出到哪里？</h2><ul><li>显示器</li><li>文件</li></ul><h2 id="print-函数的输出形式"><a href="#print-函数的输出形式" class="headerlink" title="print()函数的输出形式?"></a>print()函数的输出形式?</h2><ul><li>换行</li><li>不换行</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">520</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出到文件中</span></span><br><span class="line">fp=<span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;a+&#x27;</span>) <span class="comment"># a+的含义是以读写的方式打开这个文件</span></span><br><span class="line"><span class="comment"># 同时，参数为a+时，如果文件不存在就创建，如果文件存在就在后面追加</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;helloworld&#x27;</span>,file=fp)</span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#不进行换行输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27; love &#x27;</span>,<span class="string">&#x27;cyo&#x27;</span>,<span class="string">&#x27;!&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的::运算符</title>
      <link href="/C++%E4%B8%AD%E7%9A%84-%E8%BF%90%E7%AE%97%E7%AC%A6.html"/>
      <url>/C++%E4%B8%AD%E7%9A%84-%E8%BF%90%E7%AE%97%E7%AC%A6.html</url>
      
        <content type="html"><![CDATA[<p>$::$ 是运算符中优先级最高的，其用法有三种：</p><p>一、全局作用域符</p><p>当全局变量和局部变量重名的时候，在变量名前加上 $::$ 就可以调用全局变量</p><p>全局函数也是如此</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">用法 (::name)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=x;</span><br><span class="line">    ::sum+=sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、类作用域符</p><p>用来标明类的变量、函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">用法 (<span class="keyword">class</span>::name)</span><br><span class="line"></span><br><span class="line">Clock::<span class="built_in">SetTime</span>(<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s);</span><br></pre></td></tr></table></figure><p>三、命名空间作用域符</p><p>用来注明所使用的类、函数属于哪一个命名空间的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">用法 (<span class="keyword">namespace</span>::name)</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类与对象</title>
      <link href="/C++%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1.html"/>
      <url>/C++%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1.html</url>
      
        <content type="html"><![CDATA[<p>$C++$ 面向对象的三大特性：封装、继承、多态</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ul><li>将抽象出的数据成员、代码成员相结合，将它们视为一个整体</li><li>目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员</li></ul><h2 id="声明形式"><a href="#声明形式" class="headerlink" title="声明形式"></a>声明形式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名称&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    公有成员（外部接口）</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    私有成员</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    保护型成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$public$ ：公共权限，类内可访问、类外可访问</li><li>$protected$ ：保护权限，类内可访问、类外不可访问，儿子可以访问父亲的保护内容</li><li>$private$ ：私有权限，类内可访问、类外不可访问，儿子不可以访问父亲的私有内容<ul><li>如果紧跟在类名称的后面声明私有成员、则关键字 $private$ 可以省略</li></ul></li></ul><h2 id="访问形式"><a href="#访问形式" class="headerlink" title="访问形式"></a>访问形式</h2><ul><li><p>类中成员互访</p><ul><li><p>直接使用成员名</p></li><li><p>this-&gt;成员名</p></li><li><p>(*this).成员名</p></li></ul></li><li><p>类外访问—-仅能访问public属性的成员</p><ul><li>对象名.成员名</li><li>对象指针-&gt;成员名</li></ul></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态</p><ul><li><p>没有返回值，也不写 $void$ </p></li><li><p>在对象创建时由系统自动调用，且只会调用一次</p></li><li><p>如果程序中未声明则系统自动产生出一个默认形式的构造函数</p></li><li><p>允许为内联函数、重载函数、带默认形参值的函数</p></li></ul><p>拷贝构造函数是一种特殊的构造函数，其形参为本类的对象引用。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">类名(形参);<span class="comment">//构造函数</span></span><br><span class="line">类名(类名&amp;对象名);<span class="comment">//拷贝构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">类名::类(类名&amp;对象名)<span class="comment">//拷贝构造函数的实现</span></span><br><span class="line">&#123;函数体&#125;</span><br></pre></td></tr></table></figure><ul><li>调用函数时，若函数的形参为类对象，实参赋值给形参时，系统自动调用拷贝构造函数</li><li>当函数的返回值是类对象时，系统自动调用拷贝构造函数</li></ul><p>如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个默认的拷贝构造函数，其功能是用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。</p><p>调用拷贝构造函数的情况：</p><p>① 程序中需要新建立一个对象，并用另一个同类的对象对它初始化。</p><p>② 当函数的参数为类的对象时。在调用函数时需要将实参对象完整地传递给形参，也就是需要建立一个实参的拷贝，这就是按实参复制一个形参，系统是通过调用复制构造函数来实现的，这样能保证形参具有和实参完全相同的值。</p><p>③ 函数的返回值是类的对象。在函数调用完毕将返回值带回函数调用处时。此时需要将函数中的对象复制一个临时对象并传给该函数的调用处</p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>完成对象被删除前的一些清理工作，在对象的生存期结束的时刻系统自动调用它，然后再释<br>放此对象所属的空间</p><ul><li>如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~类名()&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Clock</span>(<span class="type">int</span> h=<span class="number">8</span>,<span class="type">int</span> m=<span class="number">0</span>,<span class="type">int</span> s=<span class="number">0</span>);    <span class="comment">//构造函数 </span></span><br><span class="line"><span class="built_in">Clock</span>(Clock &amp;clock);               <span class="comment">//拷贝构造函数 </span></span><br><span class="line">~<span class="built_in">Clock</span>();                          <span class="comment">//析构函数 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetTime</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> Hour;</span><br><span class="line"><span class="type">int</span> Minute;</span><br><span class="line"><span class="type">int</span> Second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::<span class="built_in">Clock</span>(<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s) &#123;Hour=h,Minute=m,Second=s;&#125;</span><br><span class="line"><span class="comment">//this-&gt;Hour=h;</span></span><br><span class="line"><span class="comment">//(*this).Hour=h;</span></span><br><span class="line"></span><br><span class="line">Clock::<span class="built_in">Clock</span>(Clock &amp;c)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;Hour=c.Hour;</span><br><span class="line"><span class="keyword">this</span>-&gt;Minute=c.Minute;</span><br><span class="line"><span class="keyword">this</span>-&gt;Second=c.Second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Clock::~<span class="built_in">Clock</span>() &#123;Hour=Minute=Second=<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Clock::SetTime</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(h&gt;=<span class="number">24</span>||h&lt;<span class="number">0</span>) h=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m&lt;<span class="number">0</span>||m&gt;<span class="number">60</span>) m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(s&lt;<span class="number">0</span>||s&gt;<span class="number">60</span>) s=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//if(h&gt;24||h&lt;0||m&lt;0||m&gt;60||s&lt;0||s&gt;60) return ;</span></span><br><span class="line"><span class="keyword">this</span>-&gt;Hour=h;</span><br><span class="line"><span class="keyword">this</span>-&gt;Minute=m;</span><br><span class="line"><span class="keyword">this</span>-&gt;Second=s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Clock::ShowTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">2</span>)&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>)&lt;&lt;<span class="keyword">this</span>-&gt;Hour&lt;&lt;<span class="string">&#x27;:&#x27;</span></span><br><span class="line">         &lt;&lt;<span class="built_in">setw</span>(<span class="number">2</span>)&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>)&lt;&lt;<span class="keyword">this</span>-&gt;Minute&lt;&lt;<span class="string">&#x27;:&#x27;</span></span><br><span class="line"> &lt;&lt;<span class="built_in">setw</span>(<span class="number">2</span>)&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>)&lt;&lt;<span class="keyword">this</span>-&gt;Second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Hello World&quot;</span>&lt;&lt;endl;</span><br><span class="line">Clock c1;</span><br><span class="line">c1.<span class="built_in">ShowTime</span>();                     <span class="comment">//无参构造函数 </span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n---------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="function">Clock <span class="title">c2</span><span class="params">(<span class="number">19</span>,<span class="number">34</span>,<span class="number">52</span>)</span></span>;                <span class="comment">//含参构造函数 </span></span><br><span class="line">c2.<span class="built_in">ShowTime</span>();      </span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n---------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="function">Clock <span class="title">c3</span><span class="params">(c2)</span></span>;                      <span class="comment">//拷贝构造函数 </span></span><br><span class="line">c3.<span class="built_in">ShowTime</span>();      </span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n---------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">c3.<span class="built_in">SetTime</span>(<span class="number">16</span>,<span class="number">35</span>,<span class="number">24</span>);</span><br><span class="line">c3.<span class="built_in">ShowTime</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元是 $C++$ 提供的一种破坏数据封装和数据隐藏的机制</p><p>通过将一个模块声明为另一个模块的友元，来引用另一个模块中本来被隐藏的信息。</p><p>可以使用友元函数和友元类。</p><p>为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元</p><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数是在类声明中由关键字 $friend$ 修饰说明的成员函数，在它的函数体中能够通过对象名访问 $private$ 和 $protected$ 成员</p><p>作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择。</p><p>访问对象中的成员必须通过对象名。</p><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员。</p><p>声明语法：将友元类名在另一个类中使用 $friend$ 修饰说明</p><h1 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h1><p>保持已有类的特性而构造新类的过程称为<strong>继承</strong>，在已有类的基础上新增自已的特性而产生新类的过程称为<strong>派生</strong>。<br>被继承的已有类称为基类（或父类），派生出的新类称为派生类。</p><ul><li>继承的目的：实现见代码重用</li><li>派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造</li></ul><p>声明形式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: 继承方式 基类名&#123;</span><br><span class="line">    成员声明;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h2><table><thead><tr><th>基类</th><th>公有继承</th><th>保护继承</th><th>私有继承</th></tr></thead><tbody><tr><td>public</td><td>派生类的public成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>protected</td><td>派生类的protected成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>private</td><td>在派生类中不可见</td><td>在派生类中不可见</td><td>在派生类中不可见</td></tr></tbody></table><h3 id="类型兼容规则"><a href="#类型兼容规则" class="headerlink" title="类型兼容规则"></a>类型兼容规则</h3><p>一个公有派生类的对象在使用上可以被当作基类的对象</p><p>如果  C 公有继承了 B ，则称 “C is a B”</p><ul><li>派生类的对象可以被赋值给基类对象。</li><li>派生类的对象可以初始化基类的引用。</li><li>指向基类的指针也可以指向派生类。</li></ul><p><strong>通过基类对象名、指针只能使用从基类继承的成员</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B0</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;B0::display()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>:<span class="keyword">public</span> B0 &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;B1::display()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>:<span class="keyword">public</span> B1 &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;D1::display()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(B0 *ptr)</span> </span>&#123;ptr-&gt;<span class="built_in">display</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">B0 b0,*p;</span><br><span class="line">B1 b1;</span><br><span class="line">D1 d1;</span><br><span class="line"></span><br><span class="line">p=&amp;b0,<span class="built_in">fun</span>(p);</span><br><span class="line">p=&amp;b1,<span class="built_in">fun</span>(p);</span><br><span class="line">p=&amp;d1,<span class="built_in">fun</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B0::display()</span><br><span class="line">B0::display()</span><br><span class="line">B0::display()</span><br></pre></td></tr></table></figure><p>三次调用函数都只调用了基类的display函数。</p><h2 id="单继承与多继承"><a href="#单继承与多继承" class="headerlink" title="单继承与多继承"></a>单继承与多继承</h2><ul><li>单继承：派生类只从一个基类派生</li><li>多继承：派生类从多个基类派生</li><li>多重派生：由一个基类派生出多个不同的派生类。</li><li>多层派生：派生类又作为基类，继续派生新的类。</li></ul><p>多继承派生类的声明方式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: 继承方式<span class="number">1</span> 基类名<span class="number">1</span>,继承方式<span class="number">2</span> 基类名<span class="number">2</span>，.&#123;</span><br><span class="line">    成员声明;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个“继承方式”，只用于限制对紧随其后之基类的继承。</p><h2 id="派生类的构造、析构函数"><a href="#派生类的构造、析构函数" class="headerlink" title="派生类的构造、析构函数"></a>派生类的构造、析构函数</h2><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>当基类中声明有默认形式的构造函数或未声明构造函数时，派生类构造函数可以不向基类构造函数传递参数。</li><li>若基类中未声明构造函数，派生类中也可以不声明，全采用默认形式构造函数。</li><li><strong>当基类声明有带形参的构造函数时，派生类也应声明带形参的构造函数，并将参数传递给基类构造函数。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">派生类名::派生类名(基类<span class="number">1</span>形参,基类<span class="number">2</span>形参,...基类n形参,本类形参):</span><br><span class="line">基类名<span class="number">1</span>(参数),基类名<span class="number">2</span>(参数),....基类名<span class="built_in">n</span>(参数),对象数据成员的初始化&#123;</span><br><span class="line">    本类成员初始化赋值语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数的调用顺序"><a href="#构造函数的调用顺序" class="headerlink" title="构造函数的调用顺序"></a>构造函数的调用顺序</h3><ol><li>调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向石）。</li><li>调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序</li><li>派生类的构造函数体中的内容</li></ol><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul><li>若建立派生类对象时调用默认拷贝构造函数，则编译器将自动调用基类的默认拷贝构造函数</li><li>若编写派生类的拷贝构造函数，则需要为基类相应的拷贝构造函数传递参数。</li></ul><h3 id="析构函数-1"><a href="#析构函数-1" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数也不被继承，派生类自行声明，声明方法与一般（无继承关系时）类的析构函数相同。</p><ul><li>不需要显式地调用基类的析构函数，系统会自动隐式调用</li><li>析构函数的调用次序与构造函数相反</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//基类B1,构造函数有参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B1</span>(<span class="type">int</span> i) &#123;cout&lt;&lt;<span class="string">&quot;constructing B1 &quot;</span>&lt;&lt;i&lt;&lt;endl;&#125;</span><br><span class="line">~<span class="built_in">B1</span>() &#123;cout&lt;&lt;<span class="string">&quot;destructing B1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类B2，构造函数有参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B2</span>(<span class="type">int</span> j) &#123;cout&lt;&lt;<span class="string">&quot;constructing B2 &quot;</span>&lt;&lt;j&lt;&lt;endl;&#125;</span><br><span class="line">~<span class="built_in">B2</span>() &#123;cout&lt;&lt;<span class="string">&quot;destructing B2&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类B3，构造函数无参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B3</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B3</span>() &#123;cout&lt;&lt;<span class="string">&quot;constructing B3 *&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">~<span class="built_in">B3</span>() &#123;cout&lt;&lt;<span class="string">&quot;destructing B3&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> B2, <span class="keyword">public</span> B1, <span class="keyword">public</span> B3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//派生类的公有成员</span></span><br><span class="line"><span class="built_in">C</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d):<span class="built_in">B1</span>(a),<span class="built_in">memberB2</span>(d),<span class="built_in">memberB1</span>(c),<span class="built_in">B2</span>(b) &#123;&#125;</span><br><span class="line"><span class="comment">//派生类的私有对象成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">B1 memberB1;</span><br><span class="line">B2 memberB2;</span><br><span class="line">B3 memberB3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">C <span class="title">obj</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">constructing B2 <span class="number">2</span></span><br><span class="line">constructing B1 <span class="number">1</span></span><br><span class="line">constructing B3 *</span><br><span class="line">constructing B1 <span class="number">3</span></span><br><span class="line">constructing B2 <span class="number">4</span></span><br><span class="line">constructing B3 *</span><br><span class="line">destructing B3</span><br><span class="line">destructing B2</span><br><span class="line">destructing B1</span><br><span class="line">destructing B3</span><br><span class="line">destructing B1</span><br><span class="line">destructing B2</span><br></pre></td></tr></table></figure><h2 id="派生类成员的标识与访问"><a href="#派生类成员的标识与访问" class="headerlink" title="派生类成员的标识与访问"></a>派生类成员的标识与访问</h2><h3 id="同名隐藏规则"><a href="#同名隐藏规则" class="headerlink" title="同名隐藏规则"></a>同名隐藏规则</h3><p>当派生类与基类中有同名成员时：</p><ul><li>若未显式指定类名，则通过派生类对象使用的是<strong>派生类中的同名成员</strong>。</li><li>如果派生类中声明了与基类成员函数同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏。</li><li>如要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名限定。</li></ul><h2 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h2><p>声明：用 $virtual$ 修饰说明基类 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> B</span><br></pre></td></tr></table></figure><p>作用</p><ul><li>主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题</li><li>为最远的派生类提供惟一的基类成员，而不重复产生多次拷贝。</li></ul><p>注意：</p><ul><li>在第一级继承时就要将共同基类设计为虚基类。</li></ul><p><img src="/img/Blog/22.12.23_1.png" alt="image_1"></p><h3 id="虚基类及其派生类构造函数"><a href="#虚基类及其派生类构造函数" class="headerlink" title="虚基类及其派生类构造函数"></a>虚基类及其派生类构造函数</h3><ul><li>建立对象时所指定的类称为最（远）派生类。</li><li>虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的</li><li>在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的默认构造函数</li><li>在建立对象时，<strong>只有最派生类的构造函数调用虚基类的构造函数</strong>，该派生类的其他基类对虚基类构造函数的调用被忽略</li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul><li>多态：是指发出同样的消息被不同类型的对象接收时有可能导致完全不同的行为。</li><li>目的：达到行为标识统一，减少程序中标识符的个数</li><li>实现：函数重载、运算符重载、虚函数</li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h3><ul><li>将指定的运算表达式转化为对运算符函数的调用，运算对象转化为运算符<br>函数的实参。</li><li>编系统对重载运算符的选择，遵循函数重载的选择原则，</li></ul><h3 id="规则和限制"><a href="#规则和限制" class="headerlink" title="规则和限制"></a>规则和限制</h3><ul><li><p>可以重载C++中除下列运算符外的所有运算符</p><p>.     .*      ::    ?:</p></li><li><p>只能重载C++语言中已有的运算符，不可臆造新的。</p></li><li><p>不改变原运算符的优先级和结合性</p></li><li><p>不能改变操作数个数。</p></li><li><p>经重载的运算符，其操作数中至少应该有一个是自定义类型</p></li></ul><p>两种形式：类成员函数、非成员函数（通常为友元函数）</p><p>声明形式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span> 运算符(类型 &amp;形参)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载为类成员函数时(后置++、–除外)参数个数&#x3D;原操作数个数-1<br>重载为友元函数时参数个数&#x3D;原操作数个数，且至少应该有一个自定义类型的形参。</p><h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><p>绑定：程序自身彼此关联的过程，确定程序中的操作调用与执行该操作的代码间的关系。<br>静态绑定：绑定过程出现在编译阶段，用对象名或者类名来限定要调用的函数。<br>动态绑定：绑定过程工作在程序运行时执行，在程序运行时才确定将要调用的函数</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数是动态绑定的基础，是非静态的成员函数</p><ul><li>在类的声明中，在函数原型之前写virtual。</li><li>virtual只用来说明类声明中的原型，不能用在函数实现时</li><li>具有继承性，基类中声明了虚函数，派生类中无论是否说明，同原型函数都自动为虚函数</li></ul><p>本质：不是重载声明而是覆盖<br>调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类决定调用哪个函数</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B0</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;B0::display()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>:<span class="keyword">public</span> B0 &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;B1::display()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>:<span class="keyword">public</span> B1 &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;D1::display()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(B0 *ptr)</span> </span>&#123;ptr-&gt;<span class="built_in">display</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">B0 b0,*p;</span><br><span class="line">B1 b1;</span><br><span class="line">D1 d1;</span><br><span class="line"></span><br><span class="line">p=&amp;b0,<span class="built_in">fun</span>(p);</span><br><span class="line">p=&amp;b1,<span class="built_in">fun</span>(p);</span><br><span class="line">p=&amp;d1,<span class="built_in">fun</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>何时需要虚析构函数？</p><ul><li>当你可能通过基类指针删除派生类对象时</li><li>如果你打算充许其他人通过基类指针调用对象的析构函数文（通过delete这样做是正常的），并被析构的对象是有重要的析构函数的派生类的对象，就需要让基类的析构函数成为虚拟的。</li></ul><h2 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h2><p>带有纯虚函数的类称为抽象类</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&#123;</span><br><span class="line">    <span class="keyword">virtual</span> 类型 函数名（参数表）=<span class="number">0</span>；<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>抽象类为抽象和设计的目的而声明，将有关的数据和行为组织在一个继承层次结构中，保证派生类有要求的行为，<br>对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>抽象类只能作为基类来使用。</p></li><li><p>不能声明抽象类的对象。</p></li><li><p>构造函数不能是虚函数，析构函数可以是虚函数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】前缀和、差分和离散化</title>
      <link href="/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E5%92%8C%E7%A6%BB%E6%95%A3%E5%8C%96.html"/>
      <url>/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E5%92%8C%E7%A6%BB%E6%95%A3%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>咕咕咕</p><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>咕咕咕</p><h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>咕咕咕</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P1884-USACO12FEB-Overplanting-S"><a href="#P1884-USACO12FEB-Overplanting-S" class="headerlink" title="P1884 [USACO12FEB]Overplanting S"></a>P1884 [USACO12FEB]Overplanting S</h3><p>相当于地毯（P3397）和火烧赤壁（P1496）的二合一。</p><p>观察到矩形坐标的范围远大于 $n$ 的范围，于是考虑离散化。</p><p>离散化之后变成二维线段覆盖问题，直接暴力枚举相邻的点之间的区域是否被覆盖。</p><p>这样可以过，但是程序用时直逼上限，考虑用二维差分优化。</p><p>首先离散化，处理出</p><p>设 $d[i][j]$为差分数组，则对 $d[i][j]&#x3D;a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$ </p><p>每次覆盖 $(x1,y1)$ 到 $(x2,y2)$ 的矩形时，只需修改 $d[x1][y1]++,d[x1][y2+1]–,d[x2+1][y1]–,d[x2+1][y2+1]++$</p><p>但此时下标表示的是点之间的线段，所以 $x2$ 和 $y2$ 需要减一</p><p>在修改过后对差分数组求前缀和即可得到每一块地是否被覆盖的信息</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2005</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,cntx,cnty;</span><br><span class="line">ll ans;</span><br><span class="line">ll X1[N],X2[N],Y1[N],Y2[N],x[<span class="number">2</span>*N],y[<span class="number">2</span>*N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;X1[i]&gt;&gt;Y1[i]&gt;&gt;X2[i]&gt;&gt;Y2[i];</span><br><span class="line">x[<span class="number">2</span>*i<span class="number">-1</span>]=X1[i],x[<span class="number">2</span>*i]=X2[i];</span><br><span class="line">y[<span class="number">2</span>*i<span class="number">-1</span>]=Y1[i],y[<span class="number">2</span>*i]=Y2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(x+<span class="number">1</span>,x+<span class="number">2</span>*n+<span class="number">1</span>),<span class="built_in">sort</span>(y+<span class="number">1</span>,y+<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">cntx=<span class="built_in">unique</span>(x+<span class="number">1</span>,x+<span class="number">2</span>*n+<span class="number">1</span>)-x<span class="number">-1</span>,cnty=<span class="built_in">unique</span>(y+<span class="number">1</span>,y+<span class="number">2</span>*n+<span class="number">1</span>)-y<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line"><span class="type">int</span> a1=<span class="built_in">lower_bound</span>(x+<span class="number">1</span>,x+cntx+<span class="number">1</span>,X1[k])-x;</span><br><span class="line"><span class="type">int</span> a2=<span class="built_in">lower_bound</span>(x+<span class="number">1</span>,x+cntx+<span class="number">1</span>,X2[k])-x;</span><br><span class="line"><span class="type">int</span> b1=<span class="built_in">lower_bound</span>(y+<span class="number">1</span>,y+cnty+<span class="number">1</span>,Y1[k])-y;</span><br><span class="line"><span class="type">int</span> b2=<span class="built_in">lower_bound</span>(y+<span class="number">1</span>,y+cnty+<span class="number">1</span>,Y2[k])-y;</span><br><span class="line">f[a1][b1]++,f[a1][b2]--,f[a2][b1]--,f[a2][b2]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;cntx;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;cnty;j++)&#123;</span><br><span class="line">f[i][j]+=f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>]-f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">ans+=(f[i][j]!=<span class="number">0</span>)*(x[i+<span class="number">1</span>]-x[i])*(y[j+<span class="number">1</span>]-y[j]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++指针与引用</title>
      <link href="/C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8.html"/>
      <url>/C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存地址与访问方式"><a href="#内存地址与访问方式" class="headerlink" title="内存地址与访问方式"></a>内存地址与访问方式</h1><p>内存地址：系统根据程序中定义变量的类型，给变量分配一定的长度空间。内存区的每个字节都有编号，称之为地址。</p><p>在 $C++$ 中，内存分成5个区：堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区。</p><ol><li><p>栈：由编译器自动分配释放，里面的变量通常是局部变量、函数参数等。</p></li><li><p>堆：由 <code>malloc</code> 等分配的内存块，用 <code>free</code> 来释放。</p></li><li><p>自由存储区：主要是由 <code>new​</code> 分配的内存块，释放由应用程序去控制，一般一个 $new$ 就要对应一个 $delete$ 。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p></li><li><p>全局&#x2F;静态存储区：全局变量和静态变量被分配到同一块内存中，在程序启动时分配了它们的存储，但在程序开始执行之前可能不会初始化。</p></li><li><p>常量存储区：里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）。此区域中不能存在类类型的对象。</p></li></ol><blockquote><p>Free Store<br>The free store is one of the two dynamic memory areas, allocated&#x2F;freed by new&#x2F;delete. Object lifetime can be less than the time the storage is allocated; that is, free store objects can have memory allocated without being immediately initialized, and can be destroyed without the memory being immediately deallocated. During the period when the storage is allocated but outside the object’s lifetime, the storage may be accessed and manipulated through a void* but none of the proto-object’s nonstatic members or member functions may be accessed, have their addresses taken, or be otherwise manipulated.</p><p>Heap<br>The heap is the other dynamic memory area, allocated&#x2F;freed by malloc&#x2F;free and their variants. Note that while the default global new and delete might be implemented in terms of malloc and free by a particular compiler, the heap is not the same as free store and memory allocated in one area cannot be safely deallocated in the other. Memory allocated from the heap can be used for objects of class type by placement-new construction and explicit destruction. If so used, the notes about free store object lifetime apply similarly here.</p></blockquote><p>来源：<a href="http://www.gotw.ca/gotw/009.htm">http://www.gotw.ca/gotw/009.htm</a></p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针变量：用于专门存放地址的变量。</p><h2 id="定义方式："><a href="#定义方式：" class="headerlink" title="定义方式："></a>定义方式：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类型表示符 *指针变量名;</span><br></pre></td></tr></table></figure><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>&amp;用来取变量的地址</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p=&amp;i;</span><br><span class="line"><span class="type">int</span> *p=&amp;i;</span><br></pre></td></tr></table></figure><p>*用来取指针指向地址的内容（解地址）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p,a[<span class="number">10</span>];</span><br><span class="line">p=a;</span><br><span class="line">p=&amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>注：</p><ol><li><p>void* 类型的指针可以指向任意类型的变量</p></li><li><p>指针在初始化时一般 int *p&#x3D;NULL;</p></li></ol><h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><p>存放一维或多维数组首地址的指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>,a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>]=a;</span><br><span class="line"><span class="comment">//p是一个指针，它指向包含4个元素的一维数组</span></span><br><span class="line">cout&lt;&lt;*p[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">p++;<span class="comment">//指向下一行的首地址</span></span><br><span class="line">cout&lt;&lt;*p[<span class="number">0</span>]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a代表二维数组的首地址，第<span class="number">0</span>行的地址</span><br><span class="line">a+i代表第i行的地址</span><br><span class="line">*(a+i)即a[i] 代表第i行第<span class="number">0</span>列的地址</span><br><span class="line">*(a+i)+j即a[i]+j 代表第i行第例的地址</span><br><span class="line">*(*(a+i)+j)即a[i][j] 代表第i行第j列的元素</span><br></pre></td></tr></table></figure><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>指向函数的指针变量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">返回值类型 (* 指针变量名)(形参列表);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">bool</span> (*cmp)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">    cmp=max;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">cmp</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可作为某个函数的参数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(Stu a[],<span class="type">int</span> n,<span class="built_in">bool</span> (*cmp)(<span class="type">const</span> Stu &amp;a,<span class="type">const</span> Stu &amp;b))</span><br></pre></td></tr></table></figure><h2 id="作为函数值的返回类型"><a href="#作为函数值的返回类型" class="headerlink" title="作为函数值的返回类型"></a>作为函数值的返回类型</h2><p>可用于<strong>给函数返回值赋值</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> value[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">GetPointerValue</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;<span class="keyword">return</span> &amp;value[i];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">GetPointersValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *r=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) r[i]=value[i];</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;value[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    *<span class="built_in">GetPointerValue</span>(<span class="number">0</span>)=<span class="number">-1</span>;</span><br><span class="line">    cout&lt;&lt;value[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *r=<span class="built_in">GetPointersValue</span>();</span><br><span class="line">    cout&lt;&lt;r[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;r[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;r[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用：给已有的变量取一个别名。</p><p>可理解为“名字”</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> &amp;cnt=n;</span><br></pre></td></tr></table></figure><p>&amp;不是取地址，只是描述别名。编译器不会为 $cnt$ 开辟新的空间。</p><p>引用必须初始化，且初始化后不能更改。</p><h2 id="作为函数参数"><a href="#作为函数参数" class="headerlink" title="作为函数参数"></a>作为函数参数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;a1, <span class="type">int</span> &amp;b1)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp=a1;</span><br><span class="line">    a1=b1;</span><br><span class="line">    b1=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;, b = &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">Swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;, b = &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处：</p><ol><li><p>函数内部直接通过引用来操作外部变量的值；</p></li><li><p>省去了指针的操作；</p></li><li><p>函数的形参不会拥有新的空间（节约了空间）。</p></li></ol><h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a=<span class="number">90</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="作为函数值的返回类型-1"><a href="#作为函数值的返回类型-1" class="headerlink" title="作为函数值的返回类型"></a>作为函数值的返回类型</h2><p>返回类的引用可以作为左值，并且返回的类类型引用可以直接调用成员函数来修改，返回的类类型不会调用复制构造函数。</p><p>可用于<strong>给函数返回值赋值</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">get_val</span><span class="params">(string &amp;str, string::size_type ix)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line">       cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">       <span class="built_in">get_val</span>(s, <span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">       cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态分配内存函数簇"><a href="#动态分配内存函数簇" class="headerlink" title="动态分配内存函数簇"></a>动态分配内存函数簇</h1><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>功能：在堆区开辟指定长度的空间，并且是连续的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br></pre></td></tr></table></figure><p>注：</p><ol><li><p>在调用 $malloc$ 之后，需要判断申请是否成功</p><p>失败返回 $NULL$ ，成功返回开辟好的空间的首地址</p></li><li><p>多次 $malloc$ ，申请的内存不一定是连续的</p></li><li><p>函数返回值类型为void *，需要强制类型转换</p></li></ol><h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><p>功能：在堆区申请指定大小的空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p=(<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">3</span>,<span class="number">100</span>);<span class="comment">//在内存中申请了三块，每块大小为100个字节</span></span><br></pre></td></tr></table></figure><p>注：</p><p>$calloc$ 申请的内存中的内容为0，而 $malloc$ 中的内容随机</p><h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><p>功能：在原本申请好的堆区空间的基础上重新申请内存，新开辟的空间大小为函数的第二个参数</p><p>如果原本申请好的空间的后面不足以增加指定的大小，系统会重新找一个足够大的位置开辟指定的空间，然后将原本空间中的数据拷贝过来，然后释放原本的空间</p><p>如果 $newsize$ 比原先的内存小，则会释放原先内存的后面的存储空间只留前面的 $newsize$ 个字节</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line">p=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">p=(<span class="type">char</span> *)<span class="built_in">realloc</span>(p,<span class="number">150</span>);</span><br><span class="line">p=(<span class="type">char</span> *)<span class="built_in">realloc</span>(p,<span class="number">50</span>);</span><br></pre></td></tr></table></figure><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>功能：释放堆区的空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>$free$ 函数只能释放堆区的空间</li><li>当 $free$ 后，$p$ 变成野指针了，要 $p&#x3D;NULL$</li><li>一块动态申请的内存只能 $free$ 一次，不能多次 $free$</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++运算符优先级</title>
      <link href="/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.html"/>
      <url>/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.html</url>
      
        <content type="html"><![CDATA[<p>第一级： </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[] () . -&gt;</span><br></pre></td></tr></table></figure><p>第二级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (类型) ++ -- * &amp; ! ~ sizeof</span><br></pre></td></tr></table></figure><p>第三级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ * %</span><br></pre></td></tr></table></figure><p>第四级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ -</span><br></pre></td></tr></table></figure><p>第五级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt; &gt;&gt;</span><br></pre></td></tr></table></figure><p>第六级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; &gt;= &lt; &lt;=</span><br></pre></td></tr></table></figure><p>第七级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">== !=</span><br></pre></td></tr></table></figure><p>第八~十四级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;</span><br><span class="line">^</span><br><span class="line">|</span><br><span class="line">&amp;&amp;</span><br><span class="line">||</span><br><span class="line">?:</span><br></pre></td></tr></table></figure><h1 id="逻辑中断："><a href="#逻辑中断：" class="headerlink" title="逻辑中断："></a>逻辑中断：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(表达式1)||(表达式2)</span><br><span class="line">若表达式1为真，则不执行表达式2</span><br><span class="line"></span><br><span class="line">(表达式1)&amp;&amp;(表达式2)</span><br><span class="line">若表达式1为假，则不执行表达式2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相当于电路中的断路处理，<del>可用于压行</del></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈&amp;单调队列</title>
      <link href="/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88&amp;%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97.html"/>
      <url>/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88&amp;%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>一种内部元素具有单调性的栈</p><h2 id="洛谷P2866-USACO06NOV-Bad-Hair-Day-S"><a href="#洛谷P2866-USACO06NOV-Bad-Hair-Day-S" class="headerlink" title="洛谷P2866 [USACO06NOV]Bad Hair Day S"></a>洛谷P2866 [USACO06NOV]Bad Hair Day S</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有$N (N \leq 80000)$头奶牛，每一头牛都站在一排，身高为$h_i$。<br>对于第$i$头牛前面的第$j$头牛，如果$h_i&gt;h_{i+1}$并且$h_i&gt;h_{i+2}$ $\cdots$ $h_i&gt;h_j$，那么认为第$i$头牛可以看到第$i+1$到第$j$头牛。</p><p>定义$C_i$为第$i$头牛所能看到的别的牛的数量。请帮助农夫约翰求出$\sum_{i&#x3D;1}^n C_i$.</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>考虑一头牛能被几头牛看到。</p><p>形象地来说，就是<del>如果一个人比你小，还比你强，那你就可以退役了</del></p><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】搜索技巧</title>
      <link href="/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html"/>
      <url>/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html</url>
      
        <content type="html"><![CDATA[<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>深度优先搜索（ $Depth$  $First$  $Search$  ）其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次.</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>每次寻找下一个节点的过程是重复的</li><li>如果当前节点没有未访问过的后继节点，则需要<strong>回溯</strong>到有未访问过的后继节点的一个先驱节点，继续遍历</li></ul><p>形象化描述：不撞南墙不回头</p><p>$DFS$ 一般通过递归来实现，本质上用栈来维护。</p><p>大部分 $DFS$ 算法分为三部分：</p><ol><li>判断当前位置是否合法（是否为边界）</li><li>处理信息</li><li>访问下一个位置</li></ol><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><h3 id="最优化剪枝"><a href="#最优化剪枝" class="headerlink" title="最优化剪枝"></a>最优化剪枝</h3><p>设 $g(x)$ 表示从起点走到节点 $x$ 能获得的价值，估价函数 $f(x)$ 为从节点 $x$ 走到终点能获得的最大价值。</p><p>如果 $g(x)+f(x)&lt;$ 当前的已经找到的解，则说明从节点 $x$ 走下去一定得不到最优解，可剪去此分支。</p><h4 id="洛谷P1074-NOIP2009-提高组-靶形数独"><a href="#洛谷P1074-NOIP2009-提高组-靶形数独" class="headerlink" title="洛谷P1074  [NOIP2009 提高组] 靶形数独"></a>洛谷P1074  [NOIP2009 提高组] 靶形数独</h4><p>靶形数独每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。（如图）</p><p> <img src="https://cdn.luogu.com.cn/upload/pic/28.png"> </p><p>每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。 </p><p>求出对于给定的靶形数独，能够得到的最高分数。</p><p>对于 $100%$ 的数据，数独中非 $0$ 数的个数不少于 $24$。</p><hr><p>如果当前得到的分值+之后可能得到的最大的分值还是小于之前的最优答案，结束</p><h3 id="可行性剪枝"><a href="#可行性剪枝" class="headerlink" title="可行性剪枝"></a>可行性剪枝</h3><p>如果当前位置不合法，则返回</p><h4 id="洛谷P1025-NOIP2001-提高组-数的划分"><a href="#洛谷P1025-NOIP2001-提高组-数的划分" class="headerlink" title="洛谷P1025 [NOIP2001 提高组] 数的划分"></a>洛谷P1025 [NOIP2001 提高组] 数的划分</h4><p>将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。</p><p>例如：$n&#x3D;7$，$k&#x3D;3$，下面三种分法被认为是相同的。</p><p>$1,1,5$;<br>$1,5,1$;<br>$5,1,1$.</p><p>问有多少种不同的分法。</p><p>（$6&lt;n \le 200$，$2  \le k  \le  6$）</p><hr><p>$dfs(x,r,l)$ 表示当前正在分第 $x$ 份，剩余 $r$ 没有划分，上一份大小为 $l$</p><p>当 $r&lt;0$ ，说明当前及之后所有位置全部放上个位置的数时，仍比剩余可分配的数要小，退出</p><h3 id="优化搜索顺序"><a href="#优化搜索顺序" class="headerlink" title="优化搜索顺序"></a>优化搜索顺序</h3><p>让不合法的情况在一开始就被剪掉</p><h4 id="洛谷P1074-NOIP2009-提高组-靶形数独-1"><a href="#洛谷P1074-NOIP2009-提高组-靶形数独-1" class="headerlink" title="洛谷P1074 [NOIP2009 提高组] 靶形数独"></a>洛谷P1074 [NOIP2009 提高组] 靶形数独</h4><p>从剩余未填格最少的一行或一列开始填</p><h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><p>如果当前位置之后的信息全部处理过了，就可以直接利用这些信息</p><h4 id="洛谷P1434-SHOI2002-滑雪"><a href="#洛谷P1434-SHOI2002-滑雪" class="headerlink" title="洛谷P1434 [SHOI2002] 滑雪"></a>洛谷P1434 [SHOI2002] 滑雪</h4><p>Michael 喜欢滑雪。可是为了获得速度，滑的区域必须向下倾斜。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1   2   3   4   5</span><br><span class="line">16  17  18  19  6</span><br><span class="line">15  24  25  20  7</span><br><span class="line">14  23  22  21  8</span><br><span class="line">13  12  11  10  9</span><br></pre></td></tr></table></figure><p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24$－$17$－$16$－$1$（从 $24$ 开始，在 $1$ 结束）。当然    $25$－$24$－$23$－$\ldots$－$3$－$2$－$1$ 更长。事实上，这是最长的一条。</p><p>对于 $100%$ 的数据，$1\leq R,C\leq 100$。</p><hr><p>记录从每个点开始的最长滑坡是多少</p><h3 id="玄学剪枝"><a href="#玄学剪枝" class="headerlink" title="玄学剪枝"></a>玄学剪枝</h3><h4 id="洛谷P1120-小木棍"><a href="#洛谷P1120-小木棍" class="headerlink" title="洛谷P1120 小木棍"></a>洛谷P1120 小木棍</h4><p>乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。</p><p>现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。</p><p>给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。</p><p>$1 \leq n \leq 65$，$1 \leq a_i \leq 50$。</p><hr><ol><li><p>原始长度枚举到 <strong>所有木棍的长度和 $&#x2F;2$</strong>  即可，因为此时所有木棍有可能拼成2根木棍，原始长度再大的话只能是所有木棍拼成1根。</p></li><li><p><strong>优化搜索顺序</strong>:  对输入的所有木棍按长度从大到小排序，从长到短地将木棍拼入。</p></li><li><p><strong>玄学 $next$ 数组</strong>：当dfs返回失败，需要更换当前使用的木棍时，不要再用与当前木棍的长度相同的木棍。预处理出了排序后每根木棍后面的最后一根与这根木棍长度相等的木棍（程序中的next数组），它的下一根木棍就是第一根长度不相等的木棍了。（去重）</p></li><li><p><strong>可行性剪枝</strong>: 只找木棍长度不大于未拼长度rest的所有木棍。(二分)</p></li><li><p>如果 **当前长棍剩余的未拼长度 **等于 <strong>当前木棍的长度或原始长度</strong> ，继续拼下去时却失败了，就直接回溯并改之前拼的木棍。</p></li></ol><p>​       1)  当前长棍剩余的未拼长度等于当前木棍的长度时，这根木棍在最优情况下显然是拼到这（如果用更多短木根拼完剩下的这段，把这根木棍留到后面显然不如把更多总长相等的短木棍扔到后面）。如果在最优情况下继续拼下去失败了，那肯定是之前的木棍用错了，回溯改即可。</p><p>​         2) 当前长棍剩余的未拼长度等于原始长度时，说明这根原来的长棍还一点没拼，现在正在放入一根木棍。很明显，这根木棍还没有跟其它棍子拼接，如果现在拼下去能成功话，它肯定是能用上的，即自组或与其它还没用的木棍拼接。但继续拼下去却失败，说明现在这根木棍不能用上，无法完成拼接，所以回溯改之前的木棍。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,S,L,cnt;</span><br><span class="line"><span class="type">int</span> a[<span class="number">71</span>],next[<span class="number">71</span>];</span><br><span class="line"><span class="type">bool</span> v[<span class="number">71</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> last,<span class="type">int</span> rest)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!rest)&#123;</span><br><span class="line">x++,rest=L;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(!v[i]&amp;&amp;a[i]&lt;=rest)&#123;</span><br><span class="line">v[i]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x,i,rest-a[i]);</span><br><span class="line">v[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rest==a[i]||rest==L) <span class="keyword">return</span>;</span><br><span class="line">i=next[i]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=n) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=cnt) &#123;cout&lt;&lt;L&lt;&lt;endl,<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=last+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(!v[i]&amp;&amp;a[i]&lt;=rest)&#123;</span><br><span class="line">v[i]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x,i,rest-a[i]);</span><br><span class="line">v[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rest==a[i]||rest==L) <span class="keyword">return</span>;</span><br><span class="line">i=next[i];</span><br><span class="line"><span class="keyword">if</span>(i==n) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,k;</span><br><span class="line">cin&gt;&gt;cnt;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">50</span>) <span class="keyword">continue</span>;</span><br><span class="line">a[++n]=k,S+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">next[n]=n;</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(a[i]==a[i+<span class="number">1</span>]) next[i]=next[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> next[i]=i;</span><br><span class="line"><span class="keyword">for</span>(L=a[<span class="number">1</span>];L&lt;=S/<span class="number">2</span>;L++)&#123;</span><br><span class="line">cnt=S/L;</span><br><span class="line"><span class="keyword">if</span>(S%L) <span class="keyword">continue</span>;</span><br><span class="line">v[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,L-a[<span class="number">1</span>]);</span><br><span class="line">v[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;S&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>广度优先搜索（$Broad$  $First$  $Search$ ）是一种分层的查找过程，每次将下一层的所有节点加入待访问队列，不像深度优先搜索有回溯的过程。</p><p>同时与深搜用栈来维护不同，广搜一般是用队列来进行维护的。</p><p>具体操作：它是先将起始状态加入队列，然后每次从队列中取出一个状态，将其后继状态加入队列（后继状态指的是由当前状态一步操作可以到达的状态），直到所有状态均被访问为止。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol><li><p>它并不考虑结果的可能位置，而是彻底地搜索所有状态，所以很少有基于 BFS 的启发式算法，也很少对 BFS 进行剪枝。</p></li><li><p>相对于 DFS，BFS 更加难于保存当前节点的状态，所以 BFS <strong>在爆搜中的应用较少。</strong></p></li><li><p>在某一层还没有搜索完时，是不会进入下一层的，也就是说在队列中所有同一深度的状态，是<strong>连续的一段</strong>。</p></li></ol><p>一般的代码实现方式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BFS</span>()&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(初始状态);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();  取出队首元素</span><br><span class="line">        遍历所有相邻且未加入队列的元素</span><br><span class="line">        &#123;</span><br><span class="line">            处理信息</span><br><span class="line">            q.<span class="built_in">push</span>(); 加入队列</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求最小步数一类的题目一般使用 $BFS$</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】二分学习笔记</title>
      <link href="/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>在一段单调的序列上查找一个数，可以采用折半的方法，每次将查找的范围缩小一半</p><h2 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">l=<span class="number">1</span>,r=n;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=a[mid]) r=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;l&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>查找的复杂度为$ \mathcal{O}(\text{log}n)$</p><h2 id="STL函数："><a href="#STL函数：" class="headerlink" title="STL函数："></a>STL函数：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lower_bound</span>(first,last,val);<span class="comment">//first,last及返回值都为迭代器,可在最后加比较器</span></span><br></pre></td></tr></table></figure><p>在非递减区间 $[first,last)$ 中进行二分查找，返回大于或等于 $val$ 的第一个元素位置。如果所有元素都小于 $val$ ，则返回 $last$ 的位置。</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">upper_bound</span>(first,last,val);<span class="comment">//first,last及返回值都为迭代器,可在最后加比较器</span></span><br></pre></td></tr></table></figure><p>在非递减区间 $[first,last)$ 中进行二分查找，返回大于 $val$ 的第一个元素位置。如果所有元素都小于$val$ ，则返回 $last$ 的位置。</p><h1 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h1><h2 id="适用条件："><a href="#适用条件：" class="headerlink" title="适用条件："></a>适用条件：</h2><ol><li>最优解满足单调性</li><li>最优解满足有界性</li></ol><p>即：</p><p>对于 $[a,b]$ 区间内的最优解 $x_0,$ 满足：</p><p>$\forall x_1&lt;x_0  , x_1$ 均为次优解，$\forall x_2&gt;x_0,x_2 $ 均为不可行解。</p><h2 id="模板：-1"><a href="#模板：-1" class="headerlink" title="模板："></a>模板：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123; </span><br><span class="line">mid=(l+r)/<span class="number">2</span>; </span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sol</span>(mid)) r=mid<span class="number">-1</span>; </span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line">cout&lt;&lt;l&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>大部分二分答案的题目的框架是不变的，变化的只有两个部分：</p><ol><li><p>$sol$ 函数：根据每个题目写出具体的判断函数，需要注意取等条件</p></li><li><p><strong>最终答案</strong>：需要具体判断</p><p>当 $l&#x3D;&#x3D;r$ 的时候，判断最终答案是 $l$ 还是 $l-1$</p></li></ol><p>一般来说，二分答案的题目的解很难直接求出，但很容易判断一个解是否可行</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="P3017-USACO11MAR-Brownie-Slicing-G"><a href="#P3017-USACO11MAR-Brownie-Slicing-G" class="headerlink" title="P3017 [USACO11MAR]Brownie Slicing G"></a>P3017 [USACO11MAR]Brownie Slicing G</h2><p>看到题目中的<strong>最大值最小</strong>，考虑用二分验证</p><p>前缀和维护即可</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】高精度模板</title>
      <link href="/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%A8%A1%E6%9D%BF.html"/>
      <url>/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%A8%A1%E6%9D%BF.html</url>
      
        <content type="html"><![CDATA[<h1 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h1><p><a href="https://www.luogu.com.cn/problem/P1601">P1601 A+B Problem（高精）</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">qmax</span><span class="params">(T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;<span class="keyword">if</span>(x&lt;y) x=y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l1,l2,l;</span><br><span class="line">string s1,s2;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l)</span></span>&#123;        <span class="comment">//翻转</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l/<span class="number">2</span>;i++) <span class="built_in">swap</span>(a[x][i],a[x][l-i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(l1,l2);i++)&#123;</span><br><span class="line">a[<span class="number">0</span>][i]+=a[<span class="number">1</span>][i]+a[<span class="number">2</span>][i];</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>][i]&gt;=<span class="number">10</span>) a[<span class="number">0</span>][i+<span class="number">1</span>]+=a[<span class="number">0</span>][i]/<span class="number">10</span>,a[<span class="number">0</span>][i]%=<span class="number">10</span>,l=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qmax</span>(l,<span class="built_in">max</span>(l1,l2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++) a[<span class="number">1</span>][++l1]=s1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s2.<span class="built_in">size</span>();i++) a[<span class="number">2</span>][++l2]=s2[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(<span class="number">1</span>,l1),<span class="built_in">reverse</span>(<span class="number">2</span>,l2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=l;i&gt;=<span class="number">1</span>;i--) cout&lt;&lt;a[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h1><p><a href="https://www.luogu.com.cn/problem/P1303">P1303 A*B Problem</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">qmax</span><span class="params">(T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;<span class="keyword">if</span>(x&lt;y) x=y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l1,l2,l;</span><br><span class="line">string s1,s2;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l)</span></span>&#123;        <span class="comment">//·­×ª</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l/<span class="number">2</span>;i++) <span class="built_in">swap</span>(a[x][i],a[x][l-i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Plus</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=l1;i++) </span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=l2;j++) a[<span class="number">0</span>][i+j<span class="number">-1</span>]+=a[<span class="number">1</span>][i]*a[<span class="number">2</span>][j];</span><br><span class="line"></span><br><span class="line">l=l1+l2+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=l;i++) </span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>][i]&gt;=<span class="number">10</span>) a[<span class="number">0</span>][i+<span class="number">1</span>]+=a[<span class="number">0</span>][i]/<span class="number">10</span>,a[<span class="number">0</span>][i]%=<span class="number">10</span>,<span class="built_in">qmax</span>(l,i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=l;i&gt;=<span class="number">1</span>;i--) </span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>][l]==<span class="number">0</span>) l=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++) a[<span class="number">1</span>][++l1]=s1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s2.<span class="built_in">size</span>();i++) a[<span class="number">2</span>][++l2]=s2[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(<span class="number">1</span>,l1),<span class="built_in">reverse</span>(<span class="number">2</span>,l2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Plus</span>();</span><br><span class="line"><span class="keyword">if</span>(l==<span class="number">0</span>) cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span>(i=l;i&gt;=<span class="number">1</span>;i--) cout&lt;&lt;a[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h1><p><a href="https://www.luogu.com.cn/problem/P1480">P1480 A&#x2F;B Problem</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">qmax</span><span class="params">(T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;<span class="keyword">if</span>(x&lt;y) x=y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l1,l;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line">string s1;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l)</span></span>&#123;        <span class="comment">//翻转</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l/<span class="number">2</span>;i++) <span class="built_in">swap</span>(a[i],a[l-i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Div</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l1;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">a[i<span class="number">-1</span>]+=(a[i]-(a[i]/x)*x)*<span class="number">10</span>,a[i]/=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;x;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++) a[++l1]=s1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(l1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Div</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=l1;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(a[i]!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>) cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span>(l1=i;i&gt;=<span class="number">1</span>;i--) cout&lt;&lt;a[i]; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】双指针学习笔记</title>
      <link href="/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8F%8C%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8F%8C%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>使用两个指针维护一段序列区间，保证左指针一定小于右指针，并且指针只会向右移动。</p><p>右指针每次向右移动一格；对于右指针的每一个位置，左指针也向右移动，直到所代表的区间满足条件为止。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="洛谷P1638-逛画展"><a href="#洛谷P1638-逛画展" class="headerlink" title="洛谷P1638  逛画展"></a>洛谷P1638  逛画展</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>博览馆正在展出由世上最佳的 $m$ 位画家所画的图画。</p><p>游客在购买门票时必须说明两个数字，$a$ 和 $b$，代表他要看展览中的第 $a$ 幅至第 $b$ 幅画（包含 $a,b$）之间的所有图画，而门票的价钱就是一张图画一元。</p><p>Sept 希望入场后可以看到所有名师的图画。当然，他想最小化购买门票的价格。</p><p>请求出他购买门票时应选择的 $a,b$，数据保证一定有解。</p><p>若存在多组解，<strong>输出 $a$ 最小的那组</strong>。</p><p> $1\leq n\le10^6$，$1 \leq a_i \leq m\le2\times10^3$。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>题目需要求区间的两个端点，则可用左右指针分别代表区间的两个端点。</p><p>每次左指针向右移动，直至区间里的数有 $m$ 种为止。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,ans=inf,sum,ansl,ansr;</span><br><span class="line"><span class="type">int</span> a[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">f[a[x]]++;</span><br><span class="line"><span class="keyword">if</span>(f[a[x]]==<span class="number">1</span>) sum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mns</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">f[a[x]]--;</span><br><span class="line"><span class="keyword">if</span>(f[a[x]]==<span class="number">0</span>) sum--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(r=<span class="number">1</span>;r&lt;=n;r++)&#123;</span><br><span class="line"><span class="built_in">add</span>(r);</span><br><span class="line"><span class="keyword">while</span>(sum==m&amp;&amp;l&lt;=r)&#123;</span><br><span class="line"><span class="built_in">mns</span>(++l);</span><br><span class="line"><span class="keyword">if</span>(ans&gt;r-l) ans=<span class="built_in">min</span>(ans,r-l),ansl=l,ansr=r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ansl&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ansr&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="洛谷P4653-CEOI2017-Sure-Bet"><a href="#洛谷P4653-CEOI2017-Sure-Bet" class="headerlink" title="洛谷P4653 [CEOI2017] Sure Bet"></a>洛谷P4653 [CEOI2017] Sure Bet</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>现在有 $n$ 个 $A$ 类灯泡和 $n$ 个 $B$ 类灯泡，每个灯泡都有各自的权值。</p><p>我们将这些灯泡分为 $n$ 组，每组包含一个来自A类的灯泡和一个来自B类的灯泡。</p><p>你可以从中选取任意个灯泡，每选取一个灯泡需要花费 $1$ 的代价。</p><p>在你选取完之后，系统会随机在A类和B类中选择一个类型，并点亮那一类的所有灯泡。你选取的每个点亮的灯泡会给你带来等于它权值的收益。</p><p>现在请你合理选取灯泡，以最大化可能的最小收益。你只需要求出来这个收益即可。</p><p> $1.0\le A_i,B_i\le 1000.0$，$0\le n\le 10^5$。</p><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>当选取的 $A$ 组物品总价值大于 $B$ 组时，只有从 $B$ 组选取才能达到更优解</p><p>从另一组选取时，需要使两组物品的价值尽可能相等</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">qmax</span><span class="params">(T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;<span class="keyword">if</span>(x&lt;y) x=y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N],b[N],ans1,ans2,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,l=<span class="number">0</span>,r;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp),<span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>,cmp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(r=<span class="number">1</span>;r&lt;=n;r++)&#123;</span><br><span class="line">ans1+=a[r];</span><br><span class="line"><span class="built_in">qmax</span>(ans,<span class="built_in">min</span>(ans1-(l+r),ans2-(l+r)));</span><br><span class="line"><span class="keyword">while</span>(ans2&lt;=ans1&amp;&amp;l&lt;=n) ans2+=b[++l],<span class="built_in">qmax</span>(ans,<span class="built_in">min</span>(ans1-(l+r),ans2-(l+r)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.4lf&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】常用STL函数</title>
      <link href="/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8STL%E5%87%BD%E6%95%B0.html"/>
      <url>/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8STL%E5%87%BD%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-标准模板库-STL-之Vector容器"><a href="#C-标准模板库-STL-之Vector容器" class="headerlink" title="C++标准模板库(STL)之Vector容器:"></a>C++标准模板库(STL)之Vector容器:</h1><p>是一种顺序容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能<strong>动态</strong>拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而vector正好弥补了这个缺陷，它的特征是相当于可分配拓展的数组，它的随机访问快，在末端插入和删除快，在中间插入和删除慢。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v.<span class="built_in">push_back</span>(t)  <span class="comment">//在数组的最后添加一个值为t的元素</span></span><br><span class="line">v.<span class="built_in">pop_back</span>()  <span class="comment">//去掉数组的最后一个数据 </span></span><br><span class="line">v.<span class="built_in">front</span>() 　　　<span class="comment">//返回第一个元素</span></span><br><span class="line">v.<span class="built_in">back</span>()    <span class="comment">//返回最后一个元素</span></span><br><span class="line">v.<span class="built_in">begin</span>()    <span class="comment">//得到数组头的指针，用迭代器接受</span></span><br><span class="line">v.<span class="built_in">end</span>()     <span class="comment">//得到数组的最后一个单元+1的指针，用迭代器接受</span></span><br><span class="line">v.<span class="built_in">clear</span>()    <span class="comment">// 移除容器中所有数据</span></span><br><span class="line">v.<span class="built_in">empty</span>()    <span class="comment">//判断容器是否为空吗，如果为空，则返回true 。</span></span><br><span class="line">v.<span class="built_in">erase</span>(pos)  <span class="comment">//删除pos位置的数据</span></span><br><span class="line">v.<span class="built_in">erase</span>(beg,end)<span class="comment">// 删除[beg,end)区间的数据</span></span><br><span class="line">v.<span class="built_in">size</span>()     <span class="comment">//回容器中实际数据的个数</span></span><br><span class="line">v.<span class="built_in">insert</span>(pos,data) <span class="comment">//在pos处插入数据</span></span><br><span class="line">v[n]        <span class="comment">//返回 v中位置为 n的元素。</span></span><br><span class="line">v.<span class="built_in">at</span>(n)     <span class="comment">// 返回 v中位置为 n的元素</span></span><br></pre></td></tr></table></figure><h1 id="C-标准模板库-STL-之Set容器"><a href="#C-标准模板库-STL-之Set容器" class="headerlink" title="C++标准模板库(STL)之Set容器:"></a>C++标准模板库(STL)之Set容器:</h1><p>关于set，必须说明的是set关联式容器。set作为一个容器也是用来存储同一数据类型的数据类型，并且能从一个数据集合中取出数据，在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">begin</span>()     <span class="comment">//返回指向第一个元素的迭代器</span></span><br><span class="line">s.<span class="built_in">end</span>()      <span class="comment">//返回指向最后一个元素之后的迭代器，不是最后一个元素</span></span><br><span class="line">s.<span class="built_in">clear</span>()     <span class="comment">//清除所有元素   O(n)</span></span><br><span class="line">s.<span class="built_in">count</span>()     <span class="comment">//返回某个值元素的个数O(logn)</span></span><br><span class="line">s.<span class="built_in">empty</span>()    <span class="comment">//如果集合为空，返回true</span></span><br><span class="line">s.<span class="built_in">erase</span>()     <span class="comment">//删除集合中的元素O(logn)</span></span><br><span class="line">s.<span class="built_in">find</span>()      <span class="comment">//返回一个指向被查找到元素的迭代器，如果没找到则返回end()</span></span><br><span class="line">s.<span class="built_in">insert</span>()     <span class="comment">//在集合中插入元素O(logn)</span></span><br><span class="line">s.<span class="built_in">size</span>()     <span class="comment">//集合中元素的数目O(1)</span></span><br></pre></td></tr></table></figure><h1 id="C-标准模板库-STL-之Map映射"><a href="#C-标准模板库-STL-之Map映射" class="headerlink" title="C++标准模板库(STL)之Map映射:"></a>C++标准模板库(STL)之Map映射:</h1><p>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt; m构建了一个字符串到整数的映射。</span><br><span class="line">m.<span class="built_in">begin</span>()     <span class="comment">//返回指向map头部的迭代器</span></span><br><span class="line">m.<span class="built_in">clear</span>(）     <span class="comment">////删除所有元素     O(n)</span></span><br><span class="line">m.<span class="built_in">count</span>()     <span class="comment">//返回指定元素出现的次数O(logn)</span></span><br><span class="line">m.<span class="built_in">empty</span>()     <span class="comment">//如果map为空则返回true</span></span><br><span class="line">m.<span class="built_in">end</span>()      <span class="comment">//返回指向map末尾的迭代器</span></span><br><span class="line">m.<span class="built_in">erase</span>()     <span class="comment">//删除一个元素</span></span><br><span class="line">m.<span class="built_in">find</span>()      <span class="comment">//查找一个元素</span></span><br><span class="line">m.<span class="built_in">insert</span>()    <span class="comment">// 插入元素        O(logn)</span></span><br><span class="line">m.<span class="built_in">max_size</span>()    <span class="comment">//返回可以容纳的最大元素个数</span></span><br><span class="line">m.<span class="built_in">size</span>()      <span class="comment">//返回map中元素的个数 O(1)</span></span><br><span class="line">m.<span class="built_in">swap</span>()      <span class="comment">//交换两个map</span></span><br></pre></td></tr></table></figure><h1 id="使用auto遍历STL容器："><a href="#使用auto遍历STL容器：" class="headerlink" title="使用auto遍历STL容器："></a>使用auto遍历STL容器：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue&lt;int&gt; q;</span><br><span class="line">for(auto i:q) cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日刷题记录</title>
      <link href="/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.html"/>
      <url>/%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="2023年"><a href="#2023年" class="headerlink" title="2023年"></a>2023年</h2><p>$3.14$ 洛谷 <a href="https://www.luogu.com.cn/problem/P3017">P3017 USACO11MAR]Brownie Slicing G</a> （二分+前缀和）</p><p>​         洛谷 <a href="https://www.luogu.com.cn/problem/P3406">P3406 海底高铁</a> </p><p>​         洛谷 <a href="https://www.luogu.com.cn/problem/P2882">P2882 USACO07MAR]Face The Right Way G</a> （差分）</p><p>中间写题忘记录了</p><p>$1.26$ 洛谷 <a href="https://www.luogu.com.cn/problem/P1806">P1806 跑步</a>   (背包变式)</p><p>​         洛谷  <a href="https://www.luogu.com.cn/problem/P5020">P5020 NOIP2018 提高组] 货币系统</a>    (满箱问题变形)</p><h2 id="2022年"><a href="#2022年" class="headerlink" title="2022年"></a>2022年</h2><p>$12.5$ 洛谷  [P1884 <a href="https://www.luogu.com.cn/problem/P1884">USACO12FEB]Overplanting S</a>  (二维差分+离散化)</p><p>$11.20$  洛谷  <a href="https://www.luogu.com.cn/problem/P1725">P1725 琪露诺</a>  （单调队列优化DP）</p><p>$11.15$  洛谷  <a href="https://www.luogu.com.cn/problem/P1714">P1714 切蛋糕</a>  （单调队列+前缀和）</p><p>$11.6$   洛谷  <a href="https://www.luogu.com.cn/problem/P3467">P3467 PLA-Postering</a>   (单调栈)</p><p>$11.5$  洛谷  <a href="https://www.luogu.com.cn/problem/P1578">P1578 奶牛浴场</a>  （最大子矩阵）</p><p>$10.23$  洛谷  P7910 [CSP-J 2021] 插入排序（记录下标） </p><p>$10.19$ 洛谷  P4653 [CEOI2017] Sure Bet （贪心+双指针）</p><p>$10.18$ UVA 11572 Unique Snowflakes（双指针+map）</p><p>$10.17$  洛谷  P2216​ 理想的正方形（二维单调队列）</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建中的一些坑</title>
      <link href="/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91.html"/>
      <url>/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91.html</url>
      
        <content type="html"><![CDATA[<h2 id="css无法加载"><a href="#css无法加载" class="headerlink" title="css无法加载"></a>css无法加载</h2><p>解决方法：修改_config.yml配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://username.github.io/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h2 id="博客语言为英文"><a href="#博客语言为英文" class="headerlink" title="博客语言为英文"></a>博客语言为英文</h2><p>解决方法：修改_config.yml配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure><h2 id="报错-Spawn-failed"><a href="#报错-Spawn-failed" class="headerlink" title="报错 Spawn failed"></a>报错 Spawn failed</h2><p>解决办法：依次输入以下命令</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">rm</span> <span class="string">-rf</span> <span class="string">.deploy_git/</span></span><br><span class="line"></span><br><span class="line"><span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">core.autocrlf</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="string">hexo</span> <span class="string">clean</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">g</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">d</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="修改字体后无法显示css"><a href="#修改字体后无法显示css" class="headerlink" title="修改字体后无法显示css"></a>修改字体后无法显示css</h2><p>解决办法：用hexo clean清空缓存后hexo g -d</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>建站小记</title>
      <link href="/%E5%BB%BA%E7%AB%99%E5%B0%8F%E8%AE%B0.html"/>
      <url>/%E5%BB%BA%E7%AB%99%E5%B0%8F%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<p>2020年搭了一个博客，后来电脑重装系统，于是把相关文件备份了一份。</p><p>博客迁移的时候发现_config.yml被删了，脑子一抽把github上的仓库删了又重新开了一个。</p><p>折腾了三天总算是建好了。</p><p>参考：<a href="https://xxxpt.blog.csdn.net/article/details/102557949">https://xxxpt.blog.csdn.net/article/details/102557949</a></p><p>update on 22.8.3： 换了一台游匣G15，这次迁移成功了 ^ _ ^</p><p>$$ 「路漫漫其修远兮，吾将上下而求索。」 $$</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
